// ====== FILE: .eslintrc.js ======

module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/explicit-module-boundary-types': 'warn',
    '@typescript-eslint/no-explicit-any': 'warn',
  },
};

// ====== FILE: nest-cli.json ======

{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

// ====== FILE: package.json ======

{
  "name": "et-backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@apollo/server": "^4.7.1",
    "@nestjs/apollo": "^11.0.5",
    "@nestjs/axios": "^3.0.1",
    "@nestjs/common": "^9.0.0",
    "@nestjs/config": "^2.3.1",
    "@nestjs/core": "^9.0.0",
    "@nestjs/graphql": "^11.0.5",
    "@nestjs/jwt": "^10.0.3",
    "@nestjs/platform-express": "^9.0.0",
    "@nestjs/platform-socket.io": "^9.4.3",
    "@nestjs/websockets": "^9.4.3",
    "@prisma/client": "^4.13.0",
    "bcrypt": "^5.1.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "cookie-parser": "^1.4.7",
    "dataloader": "^2.2.3",
    "graphql": "^16.6.0",
    "graphql-ws": "^5.14.3",
    "micro": "^10.0.1",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.2.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^9.0.0",
    "@nestjs/schematics": "^9.0.0",
    "@nestjs/testing": "^9.0.0",
    "@types/bcrypt": "^5.0.2",
    "@types/cookie-parser": "^1.4.8",
    "@types/express": "^4.17.13",
    "@types/jest": "29.2.4",
    "@types/node": "18.11.18",
    "@types/supertest": "^2.0.11",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.0.1",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "29.3.1",
    "prettier": "^2.3.2",
    "prisma": "^4.13.0",
    "source-map-support": "^0.5.20",
    "supertest": "^6.1.3",
    "ts-jest": "29.0.3",
    "ts-loader": "^9.2.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "4.1.1",
    "typescript": "^4.7.4",
    "webpack": "^5.88.2"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

// ====== FILE: tsconfig.build.json ======

{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

// ====== FILE: tsconfig.json ======

{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2017",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "noImplicitAny": true,
    "strictBindCallApply": true,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}

// ====== FILE: prisma\schema.prisma ======

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id       Int    @id @default(autoincrement())
  email    String @unique
  password String

  role UserRole @default(PENDING)

  times Time[]
  teams UserTeam[]

  hashedRefreshToken String?
}

enum UserRole {
  ADMIN
  ENABLER
  COLLABORATOR
  PENDING
}

model UserTeam {
  userId Int
  teamId String
  user   User   @relation(fields: [userId], references: [id])
  team   Team   @relation(fields: [teamId], references: [id])

  @@id([userId, teamId])
}

model Team {
  id   String @id
  name String

  users    UserTeam[]
  projects Project[]
  rates    Rate[]
  issues   Issue[]
}

model Rate {
  id     Int    @id @default(autoincrement())
  name   String
  teamId String
  rate   Int

  team  Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  times Time[]
}

model Project {
  id            String  @id
  estimatedTime Int?
  name          String
  teamId        String
  createdAt     String
  updatedAt     String
  description   String?
  state         String
  startDate     String?
  targetDate    String?

  time Time[]

  issues Issue[]
  team   Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model Time {
  id               Int       @id @default(autoincrement())
  startTime        DateTime
  endTime          DateTime?
  userId           Int
  projectId        String
  rateId           Int?
  totalElapsedTime Int

  user    User    @relation(fields: [userId], references: [id])
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  rate    Rate?   @relation(fields: [rateId], references: [id])
}

model Issue {
  id            String  @id
  createdAt     String
  updatedAt     String
  title         String
  dueDate       String?
  projectId     String
  priorityLabel String
  identifier    String
  assigneeName  String?
  projectName   String
  state         String
  teamKey       String?
  teamName      String?

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  team    Team?   @relation(fields: [teamKey], references: [id], onDelete: SetNull)
  labels  Label[]
}

model Label {
  id       String
  color    String
  name     String
  parentId String?
  issueId  String

  issue      Issue @relation(fields: [issueId], references: [id], onDelete: Cascade)
  internalId Int   @id @default(autoincrement())

  @@index([id, issueId], name: "idx_label_issue")
}

// ====== FILE: src\app.controller.ts ======

import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

// ====== FILE: src\app.module.ts ======

import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AuthModule } from './auth/auth.module';
import { UserModule } from './user/user.module';
import { ConfigModule } from '@nestjs/config';
import { GraphQLModule } from '@nestjs/graphql';
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';
import { WebhookModule } from './webhook/webhook.module';
import { ProjectModule } from './project/project.module';
import { IssueModule } from './issue/issue.module';
import { TeamModule } from './team/team.module';
import { RateModule } from './rate/rate.module';
import { TimeModule } from './time/time.module';
import { InvoiceModule } from './invoice/invoice.module';
import { DatabaseSyncModule } from './dbSynch/dbSynch.module';
import { HttpModule } from '@nestjs/axios';
import { IssueUpdatesModule } from './issue-updates/issue-updates.module';
import { PrismaModule } from './prisma/prisma.module';
import { Request, Response } from 'express';
import { User } from './user/user.model';

export interface GqlContext {
  req: Request & { user?: User }; // User property from AuthGuard
  res: Response;
}

@Module({
  imports: [
    ConfigModule.forRoot(),
    AuthModule,
    UserModule,
    ProjectModule,
    IssueModule,
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      autoSchemaFile: './schema.graphql',
      context: ({ req, res }: { req: Request; res: Response }): GqlContext => ({
        req: req as GqlContext['req'],
        res,
      }),
    }),
    WebhookModule,
    TeamModule,
    RateModule,
    TimeModule,
    InvoiceModule,
    DatabaseSyncModule,
    HttpModule,
    IssueUpdatesModule,
    PrismaModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

// ====== FILE: src\app.service.ts ======

import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

// ====== FILE: src\main.ts ======

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as cookieParser from 'cookie-parser';
import { ValidationPipe } from '@nestjs/common';
import { getCorsConfig } from './config/cors.config';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Add global validation pipe for DTOs and GraphQL inputs
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      forbidNonWhitelisted: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  // Apply CORS settings from centralized configuration
  app.enableCors(getCorsConfig());

  app.use(cookieParser());

  await app.listen(process.env.PORT || 8080);
  console.log(`Server is running on http://localhost:8080/graphql`);
}

bootstrap();

// ====== FILE: src\repl.ts ======

import { repl } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  await repl(AppModule);
}
bootstrap();

// ====== FILE: test\app.e2e-spec.ts ======

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;
  let jwtToken: string;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    // Login using GraphQL mutation instead of REST
    const loginMutation = `
      mutation {
        login(email: "rs@enablment.com", password: "Oldschool!") {
          access_token
          user {
            email
          }
        }
      }
    `;

    const response = await request(app.getHttpServer()).post('/graphql').send({
      query: loginMutation,
    });

    // Extract token from the GraphQL response
    jwtToken = response.body.data.login.access_token;
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .set('Authorization', `Bearer ${jwtToken}`)
      .expect(200)
      .expect('Hello World!');
  });
});

// ====== FILE: test\jest-e2e.json ======

{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

// ====== FILE: src\auth\auth.guard.ts ======

import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
  ForbiddenException,
  Logger,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Request } from 'express';
import { IS_PUBLIC_KEY } from './auth.module';
import { Reflector } from '@nestjs/core';
import { ConfigService } from '@nestjs/config';
import { UserService } from '../user/user.service';
import { UserRole } from '@prisma/client';
import { GqlExecutionContext } from '@nestjs/graphql';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private reflector: Reflector,
    private userService: UserService,
    private configService: ConfigService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const handler = context.getHandler();
    const controllerClass = context.getClass();
    console.log(
      `AuthGuard activated for: ${controllerClass?.name}.${handler?.name}`,
    );
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      handler,
      controllerClass,
    ]);
    console.log(
      `IS_PUBLIC (${controllerClass?.name}.${handler?.name}): ${isPublic}`,
    );
    if (isPublic) {
      console.log(`Route is public, skipping auth.`);
      return true;
    }
    console.log(`Route is NOT public, proceeding with auth.`);
    const ctx = context.switchToHttp();
    const graphqlCtx = GqlExecutionContext.create(context);
    const request = ctx.getRequest<Request>() || graphqlCtx.getContext().req;

    if (!request) {
      throw new UnauthorizedException('No request found');
    }

    // Extract token from cookie instead of header
    const token = this.extractTokenFromCookie(request);

    if (!token) {
      throw new UnauthorizedException('No auth token found in cookies');
    }

    try {
      // Verify the token
      const payload = await this.jwtService.verifyAsync(token, {
        secret: this.configService.get<string>('JWT_SECRET'),
      });
      console.log('auth payload contains', payload);

      interface JwtPayload {
        email: string;
        id: number;
      }
      (request as Request & { user: JwtPayload }).user = payload as JwtPayload;

      // Check for roles
      return await this.checkUserRoles(context, payload.email);
    } catch (error) {
      // Enhance and rethrow the error with custom error information
      if (error instanceof UnauthorizedException) {
        throw new UnauthorizedException({
          message: error.message,
          code: 'UNAUTHORIZED', // Custom error code
        });
      }
      if (error instanceof ForbiddenException) {
        throw new ForbiddenException({
          message: error.message,
          code: 'FORBIDDEN', // Custom error code
        });
      }
      // If it's not one of the above exceptions, rethrow the original error
      throw error;
    }
  }

  private async checkUserRoles(
    context: ExecutionContext,
    userEmail: string,
  ): Promise<boolean> {
    const requiredRoles = this.reflector.get<UserRole[]>(
      'roles',
      context.getHandler(),
    );
    if (!requiredRoles) {
      return true; // No specific roles required
    }

    const user = await this.userService.findOne(userEmail);
    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    if (!requiredRoles.includes(user.role)) {
      throw new ForbiddenException(
        'Insufficient permissions to access this resource',
      );
    }

    return true; // User has the required role
  }

  private extractTokenFromCookie(request: Request): string | undefined {
    if (!request) {
      console.log('AuthGuard: Request object is missing');
      return undefined;
    }

    console.log('AuthGuard: Cookies object:', request.cookies);

    if (!request.cookies) {
      console.log('AuthGuard: No cookies found in request');
      return undefined;
    }

    // Get the token from the auth_token cookie
    const token = request.cookies['auth_token'];
    console.log('AuthGuard: Cookie token found:', !!token);

    return token;
  }
}

// ====== FILE: src\auth\auth.module.ts ======

import { Module, forwardRef } from '@nestjs/common';
import { AuthService } from './auth.service';
import { JwtModule } from '@nestjs/jwt';
import { UserModule } from '../user/user.module';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthResolver } from './auth.resolver';
import { AuthGuard } from './auth.guard';
import { PrismaModule } from 'src/prisma/prisma.module';

export const IS_PUBLIC_KEY = 'isPublic';

@Module({
  imports: [
    ConfigModule,
    PrismaModule,
    forwardRef(() => UserModule),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        // signOptions: { expiresIn: '43200s' },
      }),
    }),
  ],
  providers: [AuthService, AuthResolver, AuthGuard],
  exports: [AuthService, JwtModule, AuthGuard],
})
export class AuthModule {}

// ====== FILE: src\auth\auth.resolver.ts ======

// src/auth/auth.resolver.ts

import { Args, Mutation, Query, Resolver, Context } from '@nestjs/graphql';
import { AuthService } from './auth.service';
import { UserProfileDto } from './dto/user-profile.dto';
import { SignInInput } from './dto/sign-in.input';
import { SignUpInput } from './dto/sign-up.input';
import { AuthResponse } from './dto/auth-response';
import { UseGuards, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { CurrentUser } from './current-user.decorator';
import { LogoutResponse } from './dto/logout-response';
import { GqlContext } from '../app.module';
import { Public } from './public.decorator';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { RefreshTokenResponse } from './dto/refresh-token-response';
import { UserRole } from '../user/user-role.enum';

@Resolver()
export class AuthResolver {
  constructor(
    private authService: AuthService,
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {}

  private setRefreshTokenCookie(context: GqlContext, token: string): void {
    if (!context?.res) {
      console.error(
        'Response object not found in context, cannot set refresh token cookie.',
      );
      return;
    }
    const refreshExpirationDays = parseInt(
      this.configService
        .get<string>('JWT_REFRESH_EXPIRATION')
        ?.replace('d', '') || '7',
      10,
    );
    const maxAgeMs = refreshExpirationDays * 24 * 60 * 60 * 1000;

    context.res.cookie('refresh_token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
      path: '/',
      maxAge: maxAgeMs,
    });
    console.log('Refresh token cookie set on path /.');
  }

  private clearRefreshTokenCookie(context: GqlContext): void {
    if (!context?.res) {
      console.error(
        'Response object not found in context, cannot clear refresh token cookie.',
      );
      return;
    }
    context.res.clearCookie('refresh_token', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
      path: '/auth/refresh',
    });
    console.log('Refresh token cookie cleared.');
  }

  @Mutation(() => AuthResponse)
  async login(
    @Context() context: GqlContext,
    @Args('input', { nullable: true }) signInInput?: SignInInput,
    @Args('email', { nullable: true }) email?: string,
    @Args('password', { nullable: true }) password?: string,
  ): Promise<Omit<AuthResponse, 'refresh_token'>> {
    const emailToUse = signInInput?.email || email;
    const passwordToUse = signInInput?.password || password;

    if (!emailToUse || !passwordToUse) {
      throw new Error('Email and password are required');
    }

    const { user, accessToken, refreshToken } = await this.authService.signIn(
      emailToUse,
      passwordToUse,
    );

    this.setRefreshTokenCookie(context, refreshToken);

    const result = {
      access_token: accessToken,
      user: new UserProfileDto({
        id: user.id,
        email: user.email,
        role: user.role as UserRole,
      }),
    };
    console.log(
      'AuthResolver.login returning:',
      JSON.stringify(result, null, 2),
    );
    return result;
  }

  @Public()
  @Mutation(() => RefreshTokenResponse)
  async refreshToken(
    @Context() context: GqlContext,
  ): Promise<RefreshTokenResponse> {
    const oldRefreshToken = context.req?.cookies?.['refresh_token'];
    console.log(
      'Refresh endpoint called. Cookie received:',
      oldRefreshToken ? 'Yes' : 'No',
    );

    if (!oldRefreshToken) {
      throw new UnauthorizedException('Refresh token not found.');
    }

    try {
      const decoded = await this.jwtService.verifyAsync<{ sub: number }>(
        oldRefreshToken,
        {
          secret: this.configService.get<string>('JWT_REFRESH_SECRET'),
        },
      );
      const userId = decoded.sub;

      const { accessToken, refreshToken: newRefreshToken } =
        await this.authService.refreshToken(userId, oldRefreshToken);

      this.setRefreshTokenCookie(context, newRefreshToken);

      return { access_token: accessToken };
    } catch (err) {
      console.error(
        'Refresh token validation or rotation failed:',
        err.message,
      );

      this.clearRefreshTokenCookie(context);
      throw new UnauthorizedException('Invalid or expired refresh token.');
    }
  }

  @Mutation(() => LogoutResponse)
  @UseGuards(AuthGuard)
  async logout(
    @CurrentUser() user: UserProfileDto,
    @Context() context: GqlContext,
  ): Promise<LogoutResponse> {
    try {
      await this.authService.logout(user.id);
    } catch (error) {
      console.error('Error during server-side logout:', error);
    }

    this.clearRefreshTokenCookie(context);

    return { success: true };
  }

  @Mutation(() => AuthResponse)
  async signup(
    @Context() context: GqlContext,
    @Args('input', { nullable: true }) signUpInput?: SignUpInput,
    @Args('email', { nullable: true }) email?: string,
    @Args('password', { nullable: true }) password?: string,
  ): Promise<Omit<AuthResponse, 'refresh_token'>> {
    const emailToUse = signUpInput?.email || email;
    const passwordToUse = signUpInput?.password || password;

    if (!emailToUse || !passwordToUse) {
      throw new Error('Email and password are required');
    }

    const createdUser = await this.authService.signUp(
      emailToUse,
      passwordToUse,
    );

    const { accessToken, refreshToken } = await this.authService.signIn(
      emailToUse,
      passwordToUse,
    );
    this.setRefreshTokenCookie(context, refreshToken);
    return {
      access_token: accessToken,
      user: new UserProfileDto({
        email: createdUser.email,
        id: createdUser.id,
        role: createdUser.role as UserRole,
      }),
    };
  }

  @Query(() => UserProfileDto)
  @UseGuards(AuthGuard)
  async me(@CurrentUser() user: UserProfileDto): Promise<UserProfileDto> {
    return user;
  }
}

// ====== FILE: src\auth\auth.service.ts ======

import {
  Injectable,
  UnauthorizedException,
  ConflictException,
  InternalServerErrorException,
  BadRequestException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UserService } from '../user/user.service';
import { User } from '@prisma/client';
import { UserRole } from '../user/user-role.enum';
import * as bcrypt from 'bcrypt';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from 'src/prisma/prisma.service';

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly prisma: PrismaService,
  ) {}

  private async generateTokens(
    user: User,
  ): Promise<{ accessToken: string; refreshToken: string }> {
    const accessTokenPayload = { email: user.email, sub: user.id };
    const refreshTokenPayload = { sub: user.id };

    const [accessToken, refreshToken] = await Promise.all([
      this.jwtService.signAsync(accessTokenPayload, {
        secret: this.configService.get<string>('JWT_ACCESS_SECRET'),
        expiresIn:
          this.configService.get<string>('JWT_ACCESS_EXPIRATION') ?? '15m',
      }),
      this.jwtService.signAsync(refreshTokenPayload, {
        secret: this.configService.get<string>('JWT_REFRESH_SECRET'),
        expiresIn:
          this.configService.get<string>('JWT_REFRESH_EXPIRATION') ?? '7d',
      }),
    ]);

    return { accessToken, refreshToken };
  }

  private async hashData(data: string): Promise<string> {
    return bcrypt.hash(data, 10);
  }

  private async updateRefreshTokenHash(
    userId: number,
    refreshToken: string | null,
  ) {
    const hashedRefreshToken = refreshToken
      ? await this.hashData(refreshToken)
      : null;

    await this.prisma.user.update({
      where: { id: userId },
      data: {
        hashedRefreshToken: hashedRefreshToken,
      },
    });
    console.log(`Updated refresh token hash for user ${userId}.`);
  }

  async signIn(
    username: string,
    pass: string,
  ): Promise<{
    user: Pick<User, 'id' | 'email' | 'role'>;
    accessToken: string;
    refreshToken: string;
  }> {
    try {
      const user = await this.userService.findOne(username);

      if (!user) {
        throw new UnauthorizedException('Invalid email or password');
      }

      const isMatch = await bcrypt.compare(pass, user.password);
      if (!isMatch) {
        throw new UnauthorizedException('Invalid email or password');
      }

      const { accessToken, refreshToken } = await this.generateTokens(user);

      await this.updateRefreshTokenHash(user.id, refreshToken);

      const result = {
        user: { id: user.id, email: user.email, role: user.role },
        accessToken,
        refreshToken,
      };
      console.log(
        'AuthService.signIn returning:',
        JSON.stringify(result, null, 2),
      );
      return result;
    } catch (error) {
      if (error instanceof UnauthorizedException) {
        throw error;
      }
      console.error('Sign in error:', error);
      throw new InternalServerErrorException(
        'An error occurred during sign in',
      );
    }
  }

  async refreshToken(
    userId: number,
    rt: string,
  ): Promise<{ accessToken: string; refreshToken: string }> {
    console.log(`Attempting refresh for user ${userId}`);
    const user = await this.prisma.user.findUnique({ where: { id: userId } });

    if (!user || !user.hashedRefreshToken) {
      console.warn(
        `Refresh Denied: User ${userId} not found or no stored hash.`,
      );
      throw new UnauthorizedException('Access Denied');
    }

    // Compare the provided token (rt) with the stored hash
    const rtMatches = await bcrypt.compare(rt, user.hashedRefreshToken);
    if (!rtMatches) {
      console.warn(
        `Refresh Denied: Provided token does not match stored hash for user ${userId}.`,
      );
      throw new UnauthorizedException('Access Denied');
    }
    console.log(`Refresh Granted: Token match successful for user ${userId}.`);

    const { accessToken, refreshToken: newRefreshToken } =
      await this.generateTokens(user);

    await this.updateRefreshTokenHash(user.id, newRefreshToken);
    console.log(`Refresh Rotation: Stored new token hash for user ${userId}.`);

    return { accessToken, refreshToken: newRefreshToken };
  }

  async logout(userId: number): Promise<boolean> {
    console.log(`Logging out user ${userId}. Clearing token hash.`);
    await this.prisma.user.updateMany({
      where: {
        id: userId,
        hashedRefreshToken: { not: null },
      },
      data: {
        hashedRefreshToken: null,
      },
    });
    return true;
  }

  async signUp(email: string, password: string): Promise<User> {
    try {
      this.validateEmail(email);
      this.validatePassword(password);

      const userCount = await this.userService.count();
      const role = userCount === 0 ? UserRole.ADMIN : UserRole.PENDING;

      const existingUser = await this.userService.findOne(email);
      if (existingUser) {
        throw new ConflictException('Email already exists');
      }

      const hashedPassword = await bcrypt.hash(password, 10);
      return this.userService.create(email, hashedPassword, role);
    } catch (error) {
      if (
        error instanceof ConflictException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }
      console.error('Sign up error:', error);
      throw new InternalServerErrorException(
        'An error occurred during sign up',
      );
    }
  }

  private validateEmail(email: string): void {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!email || !emailRegex.test(email)) {
      throw new BadRequestException('Invalid email format');
    }
  }

  private validatePassword(password: string): void {
    if (!password) {
      throw new BadRequestException('Password is required');
    }

    if (password.length < 6) {
      throw new BadRequestException(
        'Password must be at least 6 characters long',
      );
    }

    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);

    if (!(hasUpperCase && hasLowerCase && (hasNumbers || hasSpecialChar))) {
      throw new BadRequestException(
        'Password must contain at least one uppercase letter, one lowercase letter, and either a number or special character',
      );
    }
  }
}

// ====== FILE: src\auth\current-user.decorator.ts ======

import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { GqlExecutionContext } from '@nestjs/graphql';

export const CurrentUser = createParamDecorator(
  (data: unknown, context: ExecutionContext) => {
    const ctx = GqlExecutionContext.create(context);
    return ctx.getContext().req.user;
  },
);

// ====== FILE: src\auth\public.decorator.ts ======

import { SetMetadata } from '@nestjs/common';
import { IS_PUBLIC_KEY } from './auth.module';

export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);

// ====== FILE: src\auth\roles.decorator.ts ======

import { SetMetadata } from '@nestjs/common';
import { UserRole } from '@prisma/client';

export const Roles = (...roles: UserRole[]) => SetMetadata('roles', roles);

// ====== FILE: src\config\cors.config.ts ======

/**
 * Centralized CORS configuration for both HTTP and WebSocket connections
 */
export const getCorsConfig = () => {
  // Get frontend URL from environment variables or use a default for local development
  const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';

  // For production, use the configured frontend URL
  // For development, allow multiple local origins
  const origins =
    process.env.NODE_ENV === 'production'
      ? frontendUrl
      : [
          'http://localhost:3000',
          'http://localhost:4000',
          'http://127.0.0.1:3000',
        ];

  return {
    origin: origins,
    credentials: true,
  };
};

// ====== FILE: src\dbSynch\dbSynch.module.ts ======

import { Module, forwardRef } from '@nestjs/common';
import { DatabaseSyncService } from './dbSynch.service';
import { HttpModule } from '@nestjs/axios';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { PrismaModule } from '../prisma/prisma.module';
import { DatabaseSyncResolver } from './dbSynch.resolver';
import { JwtModule } from '@nestjs/jwt';
import { UserModule } from '../user/user.module';
import { AuthModule } from '../auth/auth.module';

@Module({
  imports: [
    HttpModule,
    ConfigModule,
    PrismaModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: { expiresIn: '43200s' },
      }),
    }),
    forwardRef(() => UserModule),
    forwardRef(() => AuthModule),
  ],
  providers: [DatabaseSyncService, DatabaseSyncResolver],
  exports: [DatabaseSyncService],
})
export class DatabaseSyncModule {}

// ====== FILE: src\dbSynch\dbSynch.resolver.ts ======

import { Mutation, Resolver } from '@nestjs/graphql';
import { DatabaseSyncService } from './dbSynch.service';
import { SyncResponse } from './dto/sync-response';
import { UseGuards } from '@nestjs/common';
import { AuthGuard } from '../auth/auth.guard';
import { Roles } from '../auth/roles.decorator';
import { UserRole } from '@prisma/client';

@Resolver()
export class DatabaseSyncResolver {
  constructor(private readonly databaseSyncService: DatabaseSyncService) {}

  @Mutation(() => SyncResponse)
  @UseGuards(AuthGuard)
  @Roles(UserRole.ADMIN)
  async synchronizeDatabase(): Promise<SyncResponse> {
    try {
      await this.databaseSyncService.synchronizeDatabase();
      return {
        status: 'success',
        message: 'Database synchronization completed successfully',
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      return {
        status: 'error',
        message: `Synchronization failed: ${error.message}`,
        timestamp: new Date().toISOString(),
      };
    }
  }
}

// ====== FILE: src\dbSynch\dbSynch.service.ts ======

import { Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { ConfigService } from '@nestjs/config';
import { firstValueFrom } from 'rxjs';
import { PrismaService } from '../prisma/prisma.service';

interface PageInfo {
  hasNextPage: boolean;
  endCursor: string | null;
}

interface ProjectNode {
  id: string;
  name: string;
  description: string | null;
  state: string | null;
  startDate: string | null;
  targetDate: string | null;
  createdAt: string;
  updatedAt: string;
}

interface TeamProjectsResponse {
  team?: {
    projects?: {
      pageInfo: PageInfo;
      nodes: ProjectNode[];
    };
  };
}

interface LabelNode {
  id: string;
  name: string;
  color: string;
  parentId?: string | null;
}

interface IssueNode {
  id: string;
  title: string;
  description?: string;
  state?: {
    id: string;
    name: string;
    color: string;
    type: string;
  };
  assignee?: {
    id: string;
    name: string;
  };
  project?: {
    id: string;
    name: string;
  };
  team?: {
    id: string;
    key: string;
    name: string;
  };
  priority?: number;
  priorityLabel?: string;
  identifier: string;
  dueDate: string | null;
  createdAt: string;
  updatedAt: string;
  labels?: {
    nodes: LabelNode[];
  };
}

interface IssuesResponse {
  issues: {
    pageInfo: PageInfo;
    nodes: IssueNode[];
  };
}

@Injectable()
export class DatabaseSyncService {
  private readonly logger = new Logger(DatabaseSyncService.name);
  private linearApiKey: string;

  constructor(
    private readonly httpService: HttpService,
    private readonly configService: ConfigService,
    private readonly prisma: PrismaService,
  ) {
    this.linearApiKey = this.configService.get<string>('LINEAR_KEY') || '';

    if (!this.linearApiKey) {
      this.logger.error('LINEAR_KEY not found in environment');
    }
  }

  async synchronizeDatabase(): Promise<void> {
    this.logger.log('Starting comprehensive database synchronization');

    try {
      // Use a transaction to ensure atomicity
      await this.prisma.$transaction(async (tx) => {
        // 1. Synchronize teams from Linear
        await this.synchronizeTeams(tx);

        // 2. Synchronize projects from Linear
        await this.synchronizeProjects(tx);

        // 3. Synchronize issues from Linear
        await this.synchronizeIssues(tx);

        // 4. Clean up orphaned records
        await this.cleanupOrphanedRecords(tx);
      });

      this.logger.log('Database synchronization completed successfully');
    } catch (error) {
      this.logger.error(
        `Database synchronization failed: ${error.message}`,
        error.stack,
      );
      throw new Error(`Synchronization failed: ${error.message}`);
    }
  }

  /**
   * Fetch data from Linear GraphQL API
   */
  private async fetchFromLinear<T>(query: string, variables = {}): Promise<T> {
    try {
      this.logger.debug(
        `Sending query to Linear API: ${query.substring(0, 100)}...`,
      );
      this.logger.debug(`With variables: ${JSON.stringify(variables)}`);

      // Check if API key is present
      if (!this.linearApiKey) {
        throw new Error('LINEAR_KEY is not configured');
      }

      // Make the request with proper error handling
      const response = await firstValueFrom(
        this.httpService.post(
          'https://api.linear.app/graphql',
          { query, variables },
          {
            headers: {
              'Content-Type': 'application/json',
              Authorization: this.linearApiKey, // Make sure this is a bearer token if required
            },
            timeout: 10000,
          },
        ),
      );

      // Check for GraphQL errors
      if (response.data.errors) {
        const errorMsg = response.data.errors
          .map((e: { message: string }) => e.message)
          .join(', ');
        this.logger.error(`GraphQL errors: ${errorMsg}`);
        throw new Error(`GraphQL errors: ${errorMsg}`);
      }

      return response.data.data;
    } catch (error) {
      // Log the detailed error
      if (error.response) {
        // The request was made and the server responded with a status code
        this.logger.error(
          `Linear API Error - Status: ${error.response.status}`,
        );
        this.logger.error(
          `Response data: ${JSON.stringify(error.response.data)}`,
        );
      } else if (error.request) {
        // The request was made but no response was received
        this.logger.error('Linear API Error - No response received');
      } else {
        // Something happened in setting up the request
        this.logger.error(`Linear API Error - Setup: ${error.message}`);
      }

      throw error;
    }
  }

  /**
   * Synchronize teams from Linear
   */
  public async synchronizeTeams(tx: any): Promise<void> {
    this.logger.log('Fetching teams from Linear');

    const query = `
      query {
        teams {
          nodes {
            id
            name
            key
          }
        }
      }
    `;

    try {
      const data = await this.fetchFromLinear<{
        teams: { nodes: { id: string; name: string; key: string }[] };
      }>(query);
      const teams = data.teams.nodes;

      this.logger.log(`Processing ${teams.length} teams from Linear`);

      // Get existing teams from database
      const allTeamsInDb = await tx.team.findMany({
        select: { id: true, name: true },
      });

      const teamsToDelete = new Set(
        allTeamsInDb.map((team: { id: string }) => team.id),
      );

      // Update or create teams
      for (const teamData of teams) {
        await tx.team.upsert({
          where: { id: teamData.id },
          update: { name: teamData.name },
          create: { id: teamData.id, name: teamData.name },
        });
        teamsToDelete.delete(teamData.id);
      }

      // Handle teams that don't exist in Linear
      for (const teamId of teamsToDelete) {
        this.logger.warn(`Team ${teamId} no longer exists in Linear`);
        // We don't delete teams here - this will be handled in cleanup phase
      }
    } catch (error) {
      this.logger.error(
        `Error synchronizing teams: ${error.message}`,
        error.stack,
      );
      throw error;
    }
  }
  public async synchronizeTeamsOnly(): Promise<void> {
    this.logger.log('Starting teams-only synchronization');

    try {
      await this.prisma.$transaction(async (tx) => {
        await this.synchronizeTeams(tx);
      });

      this.logger.log('Teams synchronization completed successfully');
    } catch (error) {
      this.logger.error(
        `Teams synchronization failed: ${error.message}`,
        error.stack,
      );
      throw new Error(`Teams synchronization failed: ${error.message}`);
    }
  }
  /**
   * Synchronize projects from Linear
   */
  /**
   * Synchronize projects from Linear, team by team
   */
  private async synchronizeProjects(tx: any): Promise<void> {
    this.logger.log('Fetching projects from Linear team by team');

    // 1. Fetch all teams first (we need team IDs to query projects for each team)
    const teamsQuery = `
      query {
        teams {
          nodes {
            id
          }
        }
      }
    `;
    const teamsData = await this.fetchFromLinear<{
      teams: { nodes: { id: string }[] };
    }>(teamsQuery);
    const teams = teamsData.teams.nodes;

    this.logger.log(`Fetched ${teams.length} teams to process projects for.`);

    for (const team of teams) {
      let hasNextPage = true;
      let endCursor = null;

      while (hasNextPage) {
        const query = `
            query TeamProjects($teamId: String!, $cursor: String) {
              team(id: $teamId) {
                projects(first: 100, after: $cursor) {
                  pageInfo {
                    hasNextPage
                    endCursor
                  }
                  nodes {
                    id
                    name
                    description
                    state
                    startDate
                    targetDate
                    createdAt
                    updatedAt
                    lead {
                      id
                    }
                    status {
                      id
                      name
                      type
                    }
                  }
                }
              }
            }
          `;

        try {
          const data: TeamProjectsResponse =
            await this.fetchFromLinear<TeamProjectsResponse>(query, {
              teamId: team.id,
              cursor: endCursor,
            });

          if (!data.team || !data.team.projects) {
            this.logger.warn(
              `No projects data returned for team ${team.id}. Skipping page.`,
            );
            hasNextPage = false; // No projects for this team on this page, move to next team
            continue;
          }

          const pageInfo: PageInfo = data.team.projects.pageInfo;
          const projects = data.team.projects.nodes;

          this.logger.log(
            `Processing ${projects.length} projects for team ${team.id} (cursor: ${endCursor})`,
          );

          // Get existing projects from database for this team (optimize if needed)
          const existingProjects = await tx.project.findMany({
            where: { teamId: team.id }, // Filter by team ID
            select: { id: true },
          });
          const existingProjectIds = new Set(
            existingProjects.map((p: { id: string }) => p.id),
          );

          for (const project of projects) {
            const projectData = {
              id: project.id,
              name: project.name,
              description: project.description || '',
              state: project.state || 'Active',
              createdAt: project.createdAt,
              updatedAt: project.updatedAt,
              startDate: project.startDate || null,
              targetDate: project.targetDate || null,
              teamId: team.id, // <--- Team ID is now correctly set
            };

            await tx.project.upsert({
              where: { id: project.id },
              update: projectData,
              create: projectData,
            });
            existingProjectIds.delete(project.id); // Remove processed project ID
          }

          hasNextPage = pageInfo.hasNextPage;
          endCursor = pageInfo.endCursor;

          if (hasNextPage) {
            await new Promise((resolve) => setTimeout(resolve, 500)); // Rate limit delay
          }
        } catch (error) {
          this.logger.error(
            `Error synchronizing projects for team ${team.id}: ${error.message}`,
            error.stack,
          );
          throw error; // Re-throw to halt transaction
        }
      }
    }
  }

  /**
   * Synchronize issues from Linear
   */
  private async synchronizeIssues(tx: any): Promise<void> {
    this.logger.log('Fetching issues from Linear');

    // We need to query issues with pagination because there could be many
    const pageSize = 100;
    let hasNextPage = true;
    let endCursor = null;
    let processedCount = 0;

    while (hasNextPage) {
      const query = `
        query ($cursor: String) {
          issues(first: ${pageSize}, after: $cursor) {
            pageInfo {
              hasNextPage
              endCursor
            }
            nodes {
              id
              title
              description
              state {
                id
                name
                color
                type
              }
              assignee {
                id
                name
              }
              project {
                id
                name
              }
              team {
                id
                key
                name
              }
              priority
              priorityLabel
              identifier
              dueDate
              createdAt
              updatedAt
              labels {
                nodes {
                  id
                  name
                  color
                }
              }
            }
          }
        }
      `;

      try {
        const data: IssuesResponse = await this.fetchFromLinear<IssuesResponse>(
          query,
          { cursor: endCursor },
        );
        const pageInfo: PageInfo = data.issues.pageInfo;
        const issues = data.issues.nodes;

        processedCount += issues.length;
        this.logger.log(
          `Processing ${issues.length} issues (total: ${processedCount})`,
        );

        // Update pagination info
        hasNextPage = pageInfo.hasNextPage;
        endCursor = pageInfo.endCursor;

        // Process each issue
        for (const issue of issues) {
          // Only process issues with a project
          if (issue.project && issue.team) {
            // Check if the project exists
            const projectExists = await tx.project.findUnique({
              where: { id: issue.project.id },
              select: { id: true },
            });

            if (projectExists) {
              const issueData = {
                id: issue.id,
                title: issue.title,
                createdAt: issue.createdAt,
                updatedAt: issue.updatedAt,
                projectId: issue.project.id,
                projectName: issue.project.name,
                priorityLabel: issue.priorityLabel || 'No priority',
                identifier: issue.identifier,
                assigneeName: issue.assignee
                  ? issue.assignee.name
                  : 'No assignee',
                state: issue.state ? issue.state.name : 'Triage',
                teamKey: issue.team.id,
                teamName: issue.team.name,
                dueDate: issue.dueDate || null,
              };

              // Update or create the issue
              await tx.issue.upsert({
                where: { id: issue.id },
                update: issueData,
                create: issueData,
              });

              // Process labels for this issue
              if (issue.labels && issue.labels.nodes.length > 0) {
                // First, delete any existing labels
                await tx.label.deleteMany({
                  where: { issueId: issue.id },
                });

                // Then add the current ones
                for (const label of issue.labels.nodes) {
                  await tx.label.create({
                    data: {
                      id: label.id,
                      name: label.name,
                      color: label.color,
                      parentId: label.parentId || null,
                      issueId: issue.id,
                    },
                  });
                }
              }
            } else {
              this.logger.warn(
                `Skipping issue ${issue.id}: Project ${issue.project.id} not found`,
              );
            }
          }
        }
      } catch (error) {
        this.logger.error(
          `Error synchronizing issues batch: ${error.message}`,
          error.stack,
        );
        throw error;
      }

      // Add a slight delay to avoid hitting rate limits
      if (hasNextPage) {
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }
  }

  /**
   * Clean up orphaned records after synchronization
   */
  private async cleanupOrphanedRecords(tx: any): Promise<void> {
    this.logger.log('Cleaning up orphaned records');

    // Get all Linear teams and projects
    const query = `
      query {
        teams { nodes { id } }
        projects { nodes { id } }
      }
    `;

    const data = await this.fetchFromLinear<{
      teams: { nodes: { id: string }[] };
      projects: { nodes: { id: string }[] };
    }>(query);

    const linearTeamIds = new Set(
      data.teams.nodes.map((t: { id: string }) => t.id),
    );
    const linearProjectIds = new Set(
      data.projects.nodes.map((p: { id: string }) => p.id),
    );

    // 1. Clean up orphaned projects (projects not in Linear)
    const orphanedProjects = await tx.project.findMany({
      where: {
        id: { notIn: Array.from(linearProjectIds) },
      },
      select: { id: true, name: true },
    });

    if (orphanedProjects.length > 0) {
      this.logger.warn(`Deleting ${orphanedProjects.length} orphaned projects`);
      for (const project of orphanedProjects) {
        await tx.project.delete({ where: { id: project.id } });
      }
    }

    // 2. Clean up orphaned teams (teams not in Linear)
    // Note: Be careful with teams as they might have manually created data
    const orphanedTeams = await tx.team.findMany({
      where: {
        id: { notIn: Array.from(linearTeamIds) },
      },
      include: {
        projects: { select: { id: true } },
        rates: { select: { id: true } },
      },
    });

    for (const team of orphanedTeams) {
      // Only delete teams that have no projects or rates
      if (team.projects.length === 0 && team.rates.length === 0) {
        this.logger.warn(`Deleting orphaned team: ${team.id}`);
        await tx.team.delete({ where: { id: team.id } });
      } else {
        this.logger.warn(
          `Team ${team.id} not found in Linear but has local data (${team.projects.length} projects, ${team.rates.length} rates). Keeping it.`,
        );
      }
    }

    // 3. Clean up orphaned rates (rates with invalid team references)
    const validTeamIds = new Set(
      (await tx.team.findMany({ select: { id: true } })).map(
        (t: { id: string }) => t.id,
      ),
    );

    const orphanedRates = await tx.rate.findMany({
      where: {
        teamId: { notIn: Array.from(validTeamIds) },
      },
      select: { id: true, name: true, teamId: true },
    });

    if (orphanedRates.length > 0) {
      this.logger.warn(`Deleting ${orphanedRates.length} orphaned rates`);
      for (const rate of orphanedRates) {
        await tx.rate.delete({ where: { id: rate.id } });
      }
    }
  }
}

// ====== FILE: src\invoice\invoice.input.ts ======

import { Field, InputType } from '@nestjs/graphql';
import { IsDate, IsString } from 'class-validator';
import { Type } from 'class-transformer';

@InputType()
export class InvoiceInput {
  @Field(() => String, {
    description: 'Project id for invoice',
  })
  @IsString()
  projectId: string;

  @Field(() => Date, {
    description: 'Start date for invoice period',
  })
  @IsDate()
  @Type(() => Date)
  startDate: Date;

  @Field(() => Date, {
    description: 'End date for invoice period',
  })
  @IsDate()
  @Type(() => Date)
  endDate: Date;
}

// ====== FILE: src\invoice\invoice.model.ts ======

import { ObjectType, Field, Float, Int } from '@nestjs/graphql';

@ObjectType()
export class Invoice {
  @Field(() => String)
  projectId: string;

  @Field(() => String)
  projectName: string;

  @Field(() => Float)
  totalHours: number;

  @Field(() => Float)
  totalCost: number;

  @Field(() => [RateDetail], { nullable: true })
  rates?: RateDetail[];
}

@ObjectType()
export class RateDetail {
  @Field(() => Int)
  rateId: number;

  @Field(() => String)
  rateName: string;

  @Field(() => Float)
  hours: number;

  @Field(() => Float)
  cost: number;

  @Field(() => Float)
  ratePerHour: number;
}

// ====== FILE: src\invoice\invoice.module.ts ======

import { Module } from '@nestjs/common';
import { InvoiceService } from './invoice.service';
import { InvoiceResolver } from './invoice.resolver';
import { PrismaModule } from '../prisma/prisma.module';
import { AuthModule } from '../auth/auth.module';
import { UserModule } from '../user/user.module';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [PrismaModule, AuthModule, UserModule, ConfigModule],
  providers: [InvoiceService, InvoiceResolver],
  controllers: [],
})
export class InvoiceModule {}

// ====== FILE: src\invoice\invoice.resolver.ts ======

import { Args, Query, Resolver } from '@nestjs/graphql';
import { InvoiceService } from './invoice.service';
import { Invoice } from './invoice.model';
import { InvoiceInput } from './invoice.input';
import { UseGuards } from '@nestjs/common';
import { AuthGuard } from '../auth/auth.guard';

@Resolver(() => Invoice)
@UseGuards(AuthGuard)
export class InvoiceResolver {
  constructor(private readonly invoiceService: InvoiceService) {}

  @Query(() => Invoice)
  async invoiceForProject(
    @Args('input') input: InvoiceInput,
  ): Promise<Invoice> {
    return this.invoiceService.generateInvoiceForProject(
      input.projectId,
      input.startDate,
      input.endDate,
    );
  }
}

// ====== FILE: src\invoice\invoice.service.ts ======

import {
  Injectable,
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Invoice, RateDetail } from './invoice.model';

@Injectable()
export class InvoiceService {
  constructor(private prisma: PrismaService) {}

  async generateInvoiceForProject(
    projectId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<Invoice> {
    try {
      const project = await this.prisma.project.findUnique({
        where: { id: projectId },
        include: {
          time: {
            where: {
              startTime: { gte: startDate },
              endTime: { lte: endDate },
            },
            include: {
              rate: true,
            },
          },
        },
      });

      if (!project) {
        throw new NotFoundException(`Project with ID ${projectId} not found`);
      }

      let totalHours = 0;
      let totalCost = 0;
      const ratesMap: { [key: number]: RateDetail & { ratePerHour: number } } =
        {};

      project.time.forEach((entry) => {
        if (!entry.rate) return;

        const hours = entry.totalElapsedTime / 3600000;
        totalHours += hours;
        totalCost += hours * entry.rate.rate;

        const rateId = entry.rateId as number;
        if (!ratesMap[rateId]) {
          ratesMap[rateId] = {
            rateId,
            rateName: entry.rate.name,
            hours: 0,
            cost: 0,
            ratePerHour: entry.rate.rate,
          };
        }

        ratesMap[rateId].hours += hours;
        ratesMap[rateId].cost += hours * entry.rate.rate;
      });

      const rates = Object.values(ratesMap).map((rate) => ({
        ...rate,
        hours: Math.round(rate.hours * 100) / 100,
        cost: Math.round(rate.cost * 100) / 100,
      }));

      return {
        projectId: project.id,
        projectName: project.name,
        totalHours: Math.round(totalHours * 100) / 100,
        totalCost: Math.round(totalCost * 100) / 100,
        rates,
      };
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new InternalServerErrorException(
        'Failed to generate invoice for project',
      );
    }
  }
}

// ====== FILE: src\issue\issue.model.ts ======

import { Field, ObjectType } from '@nestjs/graphql';
import { Issue as IssueClient } from '@prisma/client';

@ObjectType()
export class Issue implements IssueClient {
  @Field(() => String)
  id: string;

  @Field(() => String)
  createdAt: string;

  @Field(() => String)
  updatedAt: string;

  @Field(() => String)
  title: string;

  @Field(() => String, { nullable: true })
  dueDate: string;

  @Field(() => String)
  projectId: string;

  @Field(() => String)
  priorityLabel: string;

  @Field(() => String)
  identifier: string;

  @Field(() => String)
  assigneeName: string;

  @Field(() => String)
  projectName: string;

  @Field(() => String)
  state: string;

  @Field(() => String)
  teamKey: string;

  @Field(() => String)
  teamName: string;

  @Field(() => [Label], { nullable: 'itemsAndList' })
  labels: Label[];
}

@ObjectType()
export class Label {
  @Field(() => String)
  id: string;

  @Field(() => String)
  color: string;

  @Field(() => String)
  name: string;

  @Field(() => String, { nullable: true })
  parentId: string;
}

// ====== FILE: src\issue\issue.module.ts ======

import { Module } from '@nestjs/common';
import { IssueService } from './issue.service';
import { IssueResolver } from './issue.resolver';
import { PrismaModule } from '../prisma/prisma.module';
import { AuthModule } from '../auth/auth.module';
import { UserModule } from '../user/user.module';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [PrismaModule, AuthModule, UserModule, ConfigModule],
  providers: [IssueService, IssueResolver],
  exports: [IssueResolver],
})
export class IssueModule {}

// ====== FILE: src\issue\issue.resolver.ts ======

import { Query, Resolver } from '@nestjs/graphql';
import { IssueService } from './issue.service';
import { Issue } from './issue.model';
import { UseGuards } from '@nestjs/common';
import { AuthGuard } from '../auth/auth.guard';

@Resolver(() => Issue)
@UseGuards(AuthGuard)
export class IssueResolver {
  constructor(private issueService: IssueService) {}

  @Query(() => [Issue])
  async issues(): Promise<Issue[]> {
    const issues = await this.issueService.all();
    // Transform or assert the type as necessary
    return issues as Issue[];
  }
}

// ====== FILE: src\issue\issue.service.ts ======

import {
  Injectable,
  BadRequestException,
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Issue } from '@prisma/client';
import { IssueWebhookData } from '../webhook/webhook.service';

@Injectable()
export class IssueService {
  constructor(private prisma: PrismaService) {}

  async all(): Promise<Issue[]> {
    return this.prisma.issue.findMany({
      include: {
        labels: true,
      },
    });
  }

  async create(data: IssueWebhookData): Promise<Issue> {
    try {
      // Make sure we have a valid projectId
      if (!data.projectId) {
        console.warn(`Cannot create issue ${data.id}: Missing projectId`);
        throw new BadRequestException(
          'ProjectId is required to create an issue',
        );
      }

      const createData: any = {
        id: data.id,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
        title: data.title,
        dueDate: data.dueDate,
        priorityLabel: data.priorityLabel || 'No Priority',
        identifier: data.identifier,
        assigneeName: data.assignee?.name || 'No Assignee',
        projectName: data.project?.name || 'Unknown Project',
        state: data.state?.name,
        teamName: data.team?.name,
        projectId: data.projectId,
      };

      // Only set teamKey if team exists and has an id
      if (data.team?.id) {
        createData.teamKey = data.team.id;
      }

      const createdIssue = await this.prisma.issue.create({
        data: createData,
      });

      return createdIssue;
    } catch (error) {
      console.error('Error creating issue:', error);
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new InternalServerErrorException(
        `Failed to create issue: ${error.message}`,
      );
    }
  }

  async update(id: string, data: IssueWebhookData): Promise<Issue> {
    try {
      // First check if the issue exists
      const existingIssue = await this.prisma.issue.findUnique({
        where: { id },
        select: { id: true },
      });

      // Define update data with direct field assignments
      const updateData: any = {
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
        title: data.title,
        dueDate: data.dueDate,
        priorityLabel: data.priorityLabel || 'No Priority',
        identifier: data.identifier,
        assigneeName: data.assignee?.name || 'No Assignee',
        projectName: data.project?.name || 'Unknown Project',
        state: data.state?.name,
        teamName: data.team?.name,
      };

      // Only update projectId if it's provided
      if (data.projectId) {
        updateData.projectId = data.projectId;
      }

      // Handle team relationship directly with teamKey field
      if (data.team?.id) {
        updateData.teamKey = data.team.id;
      } else {
        updateData.teamKey = null; // Disconnect if no team
      }

      if (existingIssue) {
        // If issue exists, perform update
        const updatedIssue = await this.prisma.issue.update({
          where: { id },
          data: updateData,
        });

        console.log(`Updated issue ID: ${updatedIssue.id}`);
        return updatedIssue;
      } else {
        // If issue doesn't exist, create it
        return this.create(data);
      }
    } catch (error) {
      console.error(`Error updating issue ${id}:`, error);
      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException
      ) {
        throw error;
      }
      throw new InternalServerErrorException(
        `Failed to update issue ${id}: ${error.message}`,
      );
    }
  }

  async createLabelForIssue(
    // webhookLabel: IssueWebhookData['labels'][number],
    webhookLabel: NonNullable<IssueWebhookData['labels']>[number],
    issueId: string,
  ): Promise<void> {
    if (!webhookLabel) return;
    await this.prisma.label.create({
      data: {
        id: webhookLabel.id,
        issueId,
        color: webhookLabel.color,
        name: webhookLabel.name,
        parentId: webhookLabel.parentId,
      },
    });
  }

  async updateLabelsForIssue(
    issueId: string,
    webhookLabels: IssueWebhookData['labels'],
  ): Promise<void> {
    await this.prisma.$transaction(async (prisma) => {
      // Get all labels connected to this issue
      const currentLabels = await prisma.label.findMany({
        where: { issueId },
      });

      // Process removed labels
      const currentLabelIds = currentLabels.map((label) => label.id);
      const removedLabelIds = currentLabelIds.filter(
        (id) => !webhookLabels?.some((label) => label.id === id),
      );

      await this.prisma.label.deleteMany({
        where: {
          issueId,
          id: { in: removedLabelIds },
        },
      });

      // Process existing and new labels
      if (webhookLabels) {
        for (const webhookLabel of webhookLabels) {
          const existingLabel = currentLabels.find(
            (label) => label.id === webhookLabel.id,
          );

          if (existingLabel) {
            // Update existing label
            await this.prisma.label.update({
              where: { internalId: existingLabel.internalId },
              data: {
                color: webhookLabel.color,
                name: webhookLabel.name,
              },
            });
          } else {
            // Create new label
            await this.createLabelForIssue(webhookLabel, issueId);
          }
        }
      }
    });
  }

  async remove(id: string): Promise<void> {
    await this.prisma.issue.delete({
      where: { id },
    });
  }

  // This method will check if an issue exists and create it if not
  async ensureIssueExists(
    issueId: string,
    data: IssueWebhookData,
  ): Promise<Issue> {
    let issue = await this.prisma.issue.findUnique({
      where: { id: issueId },
    });

    if (!issue) {
      // If the issue does not exist, create it using the existing 'create' method
      issue = await this.create(data);
    } else {
      await this.update(issueId, data);
    }

    return issue;
  }
}

// ====== FILE: src\issue-updates\issue-updates.gateway.ts ======

import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Logger } from '@nestjs/common';
import { Server, Socket } from 'socket.io';
import { getCorsConfig } from '../config/cors.config';

@WebSocketGateway({
  cors: getCorsConfig(),
})
export class IssueUpdatesGateway
  implements OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer() server: Server;
  private logger: Logger = new Logger('IssueUpdatesGateway');

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
  }

  broadcastIssueUpdate(issueUpdate: any) {
    this.server.emit('issueUpdate', issueUpdate);
    this.logger.debug(`Broadcasted issue update: ${issueUpdate.id}`);
  }
}

// ====== FILE: src\issue-updates\issue-updates.module.ts ======

import { Module } from '@nestjs/common';
import { IssueUpdatesGateway } from './issue-updates.gateway';

@Module({
  providers: [IssueUpdatesGateway],
  exports: [IssueUpdatesGateway],
})
export class IssueUpdatesModule {}

// ====== FILE: src\loaders\data-loader.module.ts ======

import { Module, Scope } from '@nestjs/common';
import { PrismaModule } from '../prisma/prisma.module';
import { TeamLoader } from './team.loader';
import { ProjectLoader } from './project.loader';
import { RateLoader } from './rate.loader';

@Module({
  imports: [PrismaModule],
  providers: [TeamLoader, ProjectLoader, RateLoader],
  exports: [TeamLoader, ProjectLoader, RateLoader],
})
export class DataLoaderModule {}

// ====== FILE: src\loaders\project.loader.ts ======

import { Injectable, Scope } from '@nestjs/common';
import * as DataLoader from 'dataloader';
import { PrismaService } from '../prisma/prisma.service';
import { Project } from '@prisma/client';

@Injectable({ scope: Scope.REQUEST })
export class ProjectLoader {
  constructor(private prisma: PrismaService) {}

  readonly byId = new DataLoader<string, Project | null>(async (ids) => {
    const projects = await this.prisma.project.findMany({
      where: {
        id: { in: [...ids] },
      },
    });

    const projectMap = new Map(
      projects.map((project) => [project.id, project]),
    );

    // Return null instead of undefined for missing values
    return ids.map((id) => projectMap.get(id) || null);
  });

  readonly byTeamId = new DataLoader<string, Project[]>(async (teamIds) => {
    const projects = await this.prisma.project.findMany({
      where: {
        teamId: { in: [...teamIds] },
      },
    });

    const teamProjectsMap = new Map<string, Project[]>();

    teamIds.forEach((id) => {
      teamProjectsMap.set(id, []);
    });

    projects.forEach((project) => {
      const teamProjects = teamProjectsMap.get(project.teamId) || [];
      teamProjects.push(project);
      teamProjectsMap.set(project.teamId, teamProjects);
    });

    return teamIds.map((id) => teamProjectsMap.get(id) || []);
  });
}

// ====== FILE: src\loaders\rate.loader.ts ======

import { Injectable, Scope } from '@nestjs/common';
import * as DataLoader from 'dataloader';
import { PrismaService } from '../prisma/prisma.service';
import { Rate } from '@prisma/client';

@Injectable({ scope: Scope.REQUEST })
export class RateLoader {
  constructor(private prisma: PrismaService) {}

  readonly byId = new DataLoader<number, Rate | null>(async (ids) => {
    const rates = await this.prisma.rate.findMany({
      where: {
        id: { in: [...ids] },
      },
    });

    const rateMap = new Map(rates.map((rate) => [rate.id, rate]));
    return ids.map((id) => rateMap.get(id) || null);
  });

  readonly byTeamId = new DataLoader<string, Rate[]>(async (teamIds) => {
    const rates = await this.prisma.rate.findMany({
      where: {
        teamId: { in: [...teamIds] },
      },
    });

    const teamRatesMap = new Map<string, Rate[]>();

    teamIds.forEach((id) => {
      teamRatesMap.set(id, []);
    });

    rates.forEach((rate) => {
      const teamRates = teamRatesMap.get(rate.teamId) || [];
      teamRates.push(rate);
      teamRatesMap.set(rate.teamId, teamRates);
    });

    return teamIds.map((id) => teamRatesMap.get(id) || []);
  });
}

// ====== FILE: src\loaders\team.loader.ts ======

import { Injectable, Scope } from '@nestjs/common';
import * as DataLoader from 'dataloader';
import { PrismaService } from '../prisma/prisma.service';
import { Team } from '@prisma/client';

@Injectable({ scope: Scope.REQUEST })
export class TeamLoader {
  constructor(private prisma: PrismaService) {}

  readonly byId = new DataLoader<string, Team | null>(async (ids) => {
    const teams = await this.prisma.team.findMany({
      where: {
        id: { in: [...ids] },
      },
    });

    const teamMap = new Map(teams.map((team) => [team.id, team]));
    return ids.map((id) => teamMap.get(id) || null);
  });

  readonly byUserId = new DataLoader<number, Team[]>(async (userIds) => {
    const userTeams = await this.prisma.userTeam.findMany({
      where: {
        userId: { in: [...userIds] },
      },
      include: {
        team: true,
      },
    });

    const userTeamMap = new Map<number, Team[]>();

    userIds.forEach((id) => {
      userTeamMap.set(id, []);
    });

    userTeams.forEach((ut) => {
      const teams = userTeamMap.get(ut.userId) || [];
      teams.push(ut.team);
      userTeamMap.set(ut.userId, teams);
    });

    return userIds.map((id) => userTeamMap.get(id) || []);
  });
}

// ====== FILE: src\prisma\prisma.module.ts ======

import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}

// ====== FILE: src\prisma\prisma.service.ts ======

import {
  Injectable,
  OnModuleInit,
  OnModuleDestroy,
  Logger,
} from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  private readonly logger = new Logger(PrismaService.name);

  constructor() {
    super({
      log: ['query', 'info', 'warn', 'error'],
    });
  }

  async onModuleInit() {
    this.logger.log('Prisma Client initializing...');
    await this.$connect();
    this.logger.log('Prisma Client connected');
  }

  async onModuleDestroy() {
    this.logger.log('Prisma Client disconnecting...');
    await this.$disconnect();
    this.logger.log('Prisma Client disconnected');
  }
}

// ====== FILE: src\project\project.model.ts ======

import { Field, Int, ObjectType } from '@nestjs/graphql';
import { Project as ProjectClient } from '@prisma/client';

@ObjectType()
export class Project implements ProjectClient {
  @Field(() => String)
  id: string;

  @Field(() => Int, { nullable: true })
  estimatedTime: number | null;

  @Field(() => String)
  name: string;

  @Field(() => String)
  teamId: string;
  // ---------------------------------
  @Field(() => String)
  createdAt: string;

  @Field(() => String)
  updatedAt: string;

  @Field(() => String, { nullable: true })
  description: string | null;

  @Field(() => String)
  state: string;

  @Field(() => String, { nullable: true })
  startDate: string | null;

  @Field(() => String, { nullable: true })
  targetDate: string | null;

  // ---------------------------------
}

// ====== FILE: src\project\project.module.ts ======

import { Module } from '@nestjs/common';
import { ProjectService } from './project.service';
import { ProjectResolver } from './project.resolver';
import { PrismaModule } from '../prisma/prisma.module';
import { AuthModule } from '../auth/auth.module';
import { UserModule } from '../user/user.module';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [PrismaModule, AuthModule, UserModule, ConfigModule],
  providers: [ProjectService, ProjectResolver],
  exports: [ProjectResolver],
})
export class ProjectModule {}

// ====== FILE: src\project\project.resolver.ts ======

import { Query, Resolver } from '@nestjs/graphql';
import { Project } from './project.model';
import { ProjectService } from './project.service';
import { UseGuards } from '@nestjs/common';
import { AuthGuard } from '../auth/auth.guard';

@Resolver(() => Project)
@UseGuards(AuthGuard)
export class ProjectResolver {
  constructor(private projectService: ProjectService) {}

  @Query(() => [Project])
  async projects(): Promise<Project[]> {
    return this.projectService.all();
  }
}

// ====== FILE: src\project\project.service.ts ======

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Project } from '@prisma/client';

@Injectable()
export class ProjectService {
  constructor(private prisma: PrismaService) {}

  async all(): Promise<Project[]> {
    return this.prisma.project.findMany();
  }

  async create(
    id: string,
    name: string,
    teamId: string,
    createdAt: string,
    updatedAt: string,
    description: string,
    state: string,
    startDate: string,
    targetDate: string,
  ): Promise<Project> {
    return this.prisma.project.create({
      data: {
        id,
        name,
        team: {
          connect: { id: teamId },
        },
        createdAt,
        updatedAt,
        description,
        state,
        startDate,
        targetDate,
      },
    });
  }

  async remove(id: string): Promise<Project | null> {
    try {
      return await this.prisma.project.delete({
        where: { id },
      });
    } catch (error) {
      console.error('Error in removing project:', error);
      // Handle or rethrow the error as appropriate
      return null;
    }
  }

  async update(
    id: string,
    name: string,
    teamId: string,
    createdAt: string,
    updatedAt: string,
    description: string,
    state: string,
    startDate: string,
    targetDate: string,
  ): Promise<Project> {
    return this.prisma.project.upsert({
      where: {
        id,
      },
      update: {
        name,
        teamId,
        updatedAt,
        description,
        state,
        startDate,
        targetDate,
      },
      create: {
        id,
        name,
        teamId,
        createdAt,
        updatedAt,
        description,
        state,
        startDate,
        targetDate,
      },
    });
  }
}

// ====== FILE: src\rate\rate.input.ts ======

import { Field, InputType, Int } from '@nestjs/graphql';
import { IsNotEmpty, IsInt, IsString, Min } from 'class-validator';

@InputType()
export class RateInputCreate {
  @Field(() => String, {
    nullable: false,
    description: 'Rate name',
  })
  @IsString()
  @IsNotEmpty()
  name: string;

  @Field(() => Int, {
    nullable: false,
    description: 'Rate',
  })
  @IsInt()
  @IsNotEmpty()
  @Min(0)
  rate: number;

  @Field(() => String, {
    nullable: false,
    description: 'Rates team id',
  })
  @IsString()
  @IsNotEmpty()
  teamId: string;
}

// ====== FILE: src\rate\rate.model.ts ======

import { Field, Int, ObjectType } from '@nestjs/graphql';
import { Rate as RateClient } from '@prisma/client';

@ObjectType()
export class Rate implements RateClient {
  @Field(() => Int)
  id: number;

  @Field(() => String)
  name: string;

  @Field(() => String)
  teamId: string;

  @Field(() => Int)
  rate: number;
}

// ====== FILE: src\rate\rate.module.ts ======

import { Module } from '@nestjs/common';
import { RateService } from './rate.service';
import { RateResolver } from './rate.resolver';
import { PrismaModule } from '../prisma/prisma.module';
import { AuthModule } from '../auth/auth.module';
import { UserModule } from '../user/user.module';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [PrismaModule, AuthModule, UserModule, ConfigModule],
  providers: [RateService, RateResolver],
})
export class RateModule {}

// ====== FILE: src\rate\rate.resolver.ts ======

import { Args, Mutation, Query, Resolver, Int } from '@nestjs/graphql';
import { RateService } from './rate.service';
import { Rate } from './rate.model';
import { RateInputCreate } from './rate.input';
import { UseGuards } from '@nestjs/common';
import { AuthGuard } from '../auth/auth.guard';

@Resolver()
@UseGuards(AuthGuard)
export class RateResolver {
  constructor(private rateService: RateService) {}

  @Query(() => [Rate])
  async rates(@Args('teamId') teamId: string): Promise<Rate[]> {
    return this.rateService.all(teamId);
  }

  @Mutation(() => Rate)
  async createRate(
    @Args('rateInputCreate') rateInputCreate: RateInputCreate,
  ): Promise<Rate> {
    return this.rateService.create(
      rateInputCreate.name,
      rateInputCreate.rate,
      rateInputCreate.teamId,
    );
  }

  @Mutation(() => Rate)
  async deleteRate(
    @Args('rateId', { type: () => Int }) rateId: number,
  ): Promise<Rate> {
    console.log(`Attempting to delete rate with ID: ${rateId}`);
    return this.rateService.remove(rateId);
  }
}

// ====== FILE: src\rate\rate.service.ts ======

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Rate } from '@prisma/client';

@Injectable()
export class RateService {
  constructor(private prisma: PrismaService) {}

  all(teamId: string): Promise<Rate[]> {
    return this.prisma.rate.findMany({
      where: {
        teamId: teamId,
      },
    });
  }

  create(name: string, rate: number, teamId: string): Promise<Rate> {
    return this.prisma.rate.create({
      data: {
        name,
        rate,
        teamId,
      },
    });
  }

  async remove(id: number): Promise<Rate> {
    console.log('Removing rate with ID:', id);

    return this.prisma.$transaction(async (tx) => {
      // First, update all time entries to remove references to this rate
      await tx.time.updateMany({
        where: { rateId: id },
        data: { rateId: { set: null } },
      });

      // Then delete the rate
      try {
        return await tx.rate.delete({
          where: { id },
        });
      } catch (err) {
        console.error('Error in removing rate:', err);
        throw err;
      }
    });
  }
}

// ====== FILE: src\team\team.model.ts ======

import { Field, ObjectType } from '@nestjs/graphql';
import { Team as TeamClient } from '@prisma/client';
import { Project } from '../project/project.model';
import { Rate } from '../rate/rate.model';

@ObjectType()
export class Team implements TeamClient {
  @Field(() => String)
  id: string;

  @Field(() => String)
  name: string;

  @Field(() => [Project])
  projects: Project[];

  @Field(() => [Rate])
  rates: Rate[];
}

@ObjectType()
export class SimpleTeamDTO {
  @Field(() => String)
  id: string;

  @Field(() => String)
  name: string;
}

// ====== FILE: src\team\team.module.ts ======

import { Module } from '@nestjs/common';
import { TeamResolver } from './team.resolver';
import { TeamService } from './team.service';
import { ConfigModule } from '@nestjs/config';
import { HttpModule } from '@nestjs/axios';
import { PrismaModule } from '../prisma/prisma.module';
import { AuthModule } from '../auth/auth.module';
import { UserModule } from '../user/user.module';
import { DataLoaderModule } from '../loaders/data-loader.module';

@Module({
  imports: [
    ConfigModule,
    HttpModule,
    PrismaModule,
    AuthModule,
    UserModule,
    DataLoaderModule,
  ],
  providers: [TeamResolver, TeamService],
  exports: [TeamService],
})
export class TeamModule {}

// ====== FILE: src\team\team.resolver.ts ======

import {
  Args,
  Mutation,
  Resolver,
  Query,
  ResolveField,
  Parent,
} from '@nestjs/graphql';
import { Team } from './team.model';
import { TeamService } from './team.service';
import { SimpleTeamDTO } from './team.model';
import { UseGuards } from '@nestjs/common';
import { AuthGuard } from '../auth/auth.guard';
import { ProjectLoader } from '../loaders/project.loader';
import { RateLoader } from '../loaders/rate.loader';
import { Project } from '../project/project.model';
import { Rate } from '../rate/rate.model';

@Resolver(() => Team)
@UseGuards(AuthGuard)
export class TeamResolver {
  constructor(
    private teamService: TeamService,
    private projectLoader: ProjectLoader,
    private rateLoader: RateLoader,
  ) {}

  @Mutation(() => Team)
  async createTeam(
    @Args('id') id: string,
    @Args('name') name: string,
  ): Promise<Team> {
    const team = await this.teamService.create(id, name);
    return {
      ...team,
      projects: [],
      rates: [],
    };
  }

  @Query(() => [SimpleTeamDTO])
  async getAllSimpleTeams(): Promise<SimpleTeamDTO[]> {
    return this.teamService.getAllSimpleTeams();
  }

  @ResolveField(() => [Project])
  async projects(@Parent() team: Team): Promise<Project[]> {
    // This will be called only when projects field is requested
    // Uses DataLoader to batch and cache the requests
    return this.projectLoader.byTeamId.load(team.id);
  }

  @ResolveField(() => [Rate])
  async rates(@Parent() team: Team): Promise<Rate[]> {
    // This will be called only when rates field is requested
    // Uses DataLoader to batch and cache the requests
    return this.rateLoader.byTeamId.load(team.id);
  }
}

// ====== FILE: src\team\team.service.ts ======

import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { Team } from '@prisma/client';
import { SimpleTeamDTO } from './team.model';

@Injectable()
export class TeamService {
  private readonly logger = new Logger(TeamService.name);

  constructor(private prisma: PrismaService) {}

  async create(id: string, name: string): Promise<Team> {
    this.logger.debug(`Creating team with id: ${id}, name: ${name}`);

    return this.prisma.$transaction(async (tx) => {
      return tx.team.create({
        data: {
          id,
          name,
          projects: { create: [] },
          rates: { create: [] },
        },
      });
    });
  }

  async getAllSimpleTeams(): Promise<SimpleTeamDTO[]> {
    this.logger.debug('Fetching all teams (simple format)');

    return this.prisma.$transaction(async (tx) => {
      return tx.team.findMany({
        select: {
          id: true,
          name: true,
        },
      });
    });
  }

  async getTeamById(id: string): Promise<Team | null> {
    this.logger.debug(`Fetching team with id: ${id}`);

    return this.prisma.$transaction(async (tx) => {
      return tx.team.findUnique({
        where: { id },
      });
    });
  }
}

// ====== FILE: src\time\time.input.ts ======

// src/time/time.input.ts
import { Field, InputType, Int } from '@nestjs/graphql'; // Use Int for GraphQL
import {
  IsDate,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator'; // <--- Import these
import { Type } from 'class-transformer'; // <--- Import this

@InputType()
export class TimeInputCreate {
  @Field(() => Date, {
    // For GraphQL
    nullable: false,
    description: 'Start time',
  })
  @IsDate() // For ValidationPipe
  @IsNotEmpty() // For ValidationPipe
  @Type(() => Date) // For ValidationPipe (transform)
  startTime: Date;

  @Field(() => Date, {
    // For GraphQL
    nullable: true,
    description: 'End time',
  })
  @IsOptional() // For ValidationPipe
  @IsDate() // For ValidationPipe
  @Type(() => Date) // For ValidationPipe (transform)
  endTime?: Date;

  @Field(() => String, {
    // For GraphQL
    nullable: false,
    description: 'Project ID',
  })
  @IsString() // For ValidationPipe
  @IsNotEmpty() // For ValidationPipe
  projectId: string;

  @Field(() => Int, {
    // For GraphQL (Use Int)
    nullable: false,
    description: 'User ID',
  })
  @IsNumber() // For ValidationPipe
  @IsNotEmpty() // For ValidationPipe
  userId: number;

  @Field(() => Int, {
    // For GraphQL (Use Int)
    nullable: false,
    description: 'Rate ID',
  })
  @IsNumber() // For ValidationPipe
  @IsNotEmpty() // For ValidationPipe
  rateId: number;

  @Field(() => Int, {
    // For GraphQL (Use Int)
    nullable: false,
    description: 'Total Elapsed Time',
  })
  @IsNumber() // For ValidationPipe
  @IsNotEmpty() // For ValidationPipe
  totalElapsedTime: number;
}

// Add relevant validators to TimeInputUpdate as well
@InputType()
export class TimeInputUpdate {
  @Field(() => Int, {
    // Use Int
    nullable: false,
    description: 'Time entry ID',
  })
  @IsNumber()
  @IsNotEmpty()
  id: number;

  @Field(() => Date, {
    nullable: true,
    description: 'End time',
  })
  @IsOptional()
  @IsDate()
  @Type(() => Date)
  endTime?: Date;

  @Field(() => Int, {
    // Use Int
    nullable: false,
    description: 'Total Elapsed Time',
  })
  @IsNumber()
  @IsNotEmpty()
  totalElapsedTime: number;
}

// ====== FILE: src\time\time.model.ts ======

import { Field, ObjectType, Int } from '@nestjs/graphql';
import { Time as TimeClient } from '@prisma/client';

@ObjectType()
export class Time implements TimeClient {
  @Field(() => Int)
  id: number;

  @Field(() => Date)
  startTime: Date;

  @Field(() => Date, { nullable: true })
  endTime: Date | null;

  @Field(() => Int)
  userId: number;

  @Field(() => String)
  projectId: string;

  @Field(() => Int, { nullable: true })
  rateId: number | null;

  // @Field(() => Int, { nullable: true })
  // totalElapsedTime: number | null;

  @Field(() => Int)
  totalElapsedTime: number;
}

// ====== FILE: src\time\time.module.ts ======

import { Module } from '@nestjs/common';
import { TimeService } from './time.service';
import { TimeResolver } from './time.resolver';
import { PrismaModule } from '../prisma/prisma.module';
import { AuthModule } from '../auth/auth.module';
import { UserModule } from '../user/user.module';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [PrismaModule, AuthModule, UserModule, ConfigModule],
  providers: [TimeService, TimeResolver],
})
export class TimeModule {}

// ====== FILE: src\time\time.resolver.ts ======

import { Resolver, Query, Mutation, Args } from '@nestjs/graphql';
import { TimeService } from './time.service';
import { Time } from './time.model';
import { TimeInputCreate, TimeInputUpdate } from './time.input';
import { UseGuards } from '@nestjs/common';
import { AuthGuard } from '../auth/auth.guard';

@Resolver(() => Time)
@UseGuards(AuthGuard)
export class TimeResolver {
  constructor(private readonly timeService: TimeService) {}

  @Query(() => [Time])
  async times(@Args('projectId') projectId: string): Promise<Time[]> {
    return this.timeService.all(projectId);
  }

  @Mutation(() => Time)
  async createTime(
    @Args('timeInputCreate') timeInputCreate: TimeInputCreate,
  ): Promise<Time> {
    console.log(
      'Backend Resolver - Received Start Time:',
      timeInputCreate.startTime,
    );
    console.log(
      'Backend Resolver - Received End Time:',
      timeInputCreate.endTime,
    );
    const { startTime, projectId, userId, rateId, totalElapsedTime, endTime } =
      timeInputCreate;

    // Find an existing entry
    const existingEntry = await this.timeService.findExistingEntry(
      startTime,
      userId,
      projectId,
      rateId,
    );

    if (existingEntry) {
      return this.timeService.update(
        existingEntry.id,
        new Date(),
        totalElapsedTime,
      );
    } else {
      return this.timeService.create(
        startTime,
        projectId,
        userId,
        rateId,
        endTime ? new Date(endTime) : new Date(),
        totalElapsedTime,
      );
    }
  }

  @Mutation(() => Time)
  async updateTime(
    @Args('timeInputUpdate') timeInputUpdate: TimeInputUpdate,
  ): Promise<Time> {
    const { id, endTime, totalElapsedTime } = timeInputUpdate;
    return this.timeService.update(id, endTime ?? new Date(), totalElapsedTime);
  }

  @Query(() => Number)
  async getTotalTimeSpent(
    @Args('userId') userId: number,
    @Args('projectId') projectId: string,
    @Args('startDate') startDate: string,
    @Args('endDate') endDate: string,
  ): Promise<number> {
    return this.timeService.getTotalTimeSpent(
      userId,
      projectId,
      new Date(startDate),
      new Date(endDate),
    );
  }

  @Query(() => Number)
  async getTotalTimeForUserProject(
    @Args('userId') userId: number,
    @Args('projectId') projectId: string,
  ): Promise<number> {
    return this.timeService.getTotalTimeForUserProject(userId, projectId);
  }

  @Mutation(() => Time)
  async deleteTime(@Args('id') id: number): Promise<Time> {
    return this.timeService.remove(id);
  }
}

// ====== FILE: src\time\time.service.ts ======

import {
  Injectable,
  ConflictException,
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Time } from '@prisma/client';

@Injectable()
export class TimeService {
  constructor(private prisma: PrismaService) {}

  all(projectId: string): Promise<Time[]> {
    return this.prisma.time.findMany({
      where: {
        projectId,
      },
    });
  }

  async isDuplicate(
    startTime: Date,
    userId: number,
    projectId: string,
    rateId: number,
  ): Promise<boolean> {
    const existingEntry = await this.prisma.time.findFirst({
      where: {
        startTime,
        userId,
        projectId,
        rateId,
      },
    });
    return !!existingEntry;
  }

  async findExistingEntry(
    startTime: Date,
    userId: number,
    projectId: string,
    rateId: number,
  ): Promise<Time | null> {
    return this.prisma.time.findFirst({
      where: {
        startTime,
        userId,
        projectId,
        rateId,
      },
    });
  }

  async create(
    startTime: Date,
    projectId: string,
    userId: number,
    rateId: number,
    endTime: Date,
    totalElapsedTime: number,
  ): Promise<Time> {
    try {
      console.log('Backend Service - Creating with Start Time:', startTime);
      console.log('Backend Service - Creating with End Time:', endTime);

      const duplicate = await this.isDuplicate(
        startTime,
        userId,
        projectId,
        rateId,
      );

      if (duplicate) {
        throw new ConflictException('Duplicate time entry not allowed');
      }

      return this.prisma.time.create({
        data: {
          startTime,
          endTime, // endTime is now the actual time of submission
          projectId,
          userId,
          rateId,
          totalElapsedTime, // totalElapsedTime is the total active working time
        },
      });
    } catch (error) {
      if (error instanceof ConflictException) {
        throw error;
      }
      throw new InternalServerErrorException('Failed to create time entry');
    }
  }

  async update(
    id: number,
    endTime: Date,
    totalElapsedTime: number, // Directly use the provided totalElapsedTime
  ): Promise<Time> {
    try {
      // First check if the time entry exists
      const timeEntry = await this.prisma.time.findUnique({
        where: { id },
      });

      if (!timeEntry) {
        throw new NotFoundException(`Time entry with ID ${id} not found`);
      }

      return this.prisma.time.update({
        where: { id },
        data: {
          endTime, // Set the endTime to the time of submission
          totalElapsedTime, // Use the provided totalElapsedTime
        },
      });
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new InternalServerErrorException(
        `Failed to update time entry ${id}`,
      );
    }
  }

  async remove(id: number): Promise<Time> {
    try {
      // First check if the time entry exists
      const timeEntry = await this.prisma.time.findUnique({
        where: { id },
      });

      if (!timeEntry) {
        throw new NotFoundException(`Time entry with ID ${id} not found`);
      }

      return this.prisma.time.delete({
        where: { id },
      });
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new InternalServerErrorException(
        `Failed to delete time entry ${id}`,
      );
    }
  }

  async getTotalTimeSpent(
    userId: number,
    projectId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<number> {
    try {
      console.log(
        `getTotalTimeSpent called with userId: ${userId}, projectId: ${projectId}, startDate: ${startDate.toISOString()}, endDate: ${endDate.toISOString()}`,
      );

      // Adjust startDate to the start of the day
      const adjustedStartDate = new Date(startDate);
      adjustedStartDate.setHours(0, 0, 0, 0);

      // Adjust endDate to include the entire day
      const adjustedEndDate = new Date(endDate);
      adjustedEndDate.setHours(23, 59, 59, 999);

      console.log('Executing database query to aggregate total time spent...');

      const aggregatedTime = await this.prisma.time.aggregate({
        where: {
          userId,
          projectId,
          AND: [
            {
              startTime: {
                gte: adjustedStartDate,
              },
            },
            {
              endTime: {
                lte: adjustedEndDate,
              },
            },
          ],
        },
        _sum: {
          totalElapsedTime: true,
        },
      });

      const totalTime = aggregatedTime._sum.totalElapsedTime || 0;
      console.log(`Total time spent for the given period: ${totalTime}`);
      return totalTime;
    } catch (error) {
      console.error('Error in getTotalTimeSpent:', error);
      throw new InternalServerErrorException(
        'Failed to calculate total time spent',
      );
    }
  }

  async getTotalTimeForUserProject(
    userId: number,
    projectId: string,
  ): Promise<number> {
    try {
      const aggregatedTime = await this.prisma.time.aggregate({
        where: {
          userId,
          projectId,
        },
        _sum: {
          totalElapsedTime: true,
        },
      });

      return aggregatedTime._sum.totalElapsedTime || 0;
    } catch (error) {
      throw new InternalServerErrorException(
        'Failed to calculate total time for user project',
      );
    }
  }
}

// ====== FILE: src\user\user-role.enum.ts ======

import { registerEnumType } from '@nestjs/graphql';

export enum UserRole {
  ADMIN = 'ADMIN',
  ENABLER = 'ENABLER',
  COLLABORATOR = 'COLLABORATOR',
  PENDING = 'PENDING',
}

registerEnumType(UserRole, {
  name: 'UserRole',
});

// ====== FILE: src\user\user.input.ts ======

import { Field, InputType } from '@nestjs/graphql';
import { UserRole } from './user-role.enum';

@InputType()
export class UserInputCreate {
  @Field(() => String, {
    nullable: false,
    description: "User's email",
  })
  email: string;

  @Field(() => String, {
    nullable: false,
    description: "User's password",
  })
  password: string;

  @Field(() => UserRole, {
    nullable: true,
    description: "User's role",
  })
  role?: UserRole;
}

// ====== FILE: src\user\user.model.ts ======

import { Field, Int, ObjectType } from '@nestjs/graphql';
import { UserRole } from './user-role.enum';
import { Team } from '../team/team.model';

@ObjectType()
export class User {
  @Field(() => Int)
  id: number;

  @Field(() => String)
  email: string;

  @Field(() => UserRole)
  role: UserRole;

  @Field(() => [Team])
  teams?: Team[];
}

// ====== FILE: src\user\user.module.ts ======

import { Module, forwardRef } from '@nestjs/common';
import { UserService } from './user.service';
import { UserResolver } from './user.resolver';
import { AuthModule } from '../auth/auth.module';
import { PrismaModule } from '../prisma/prisma.module';
import { ConfigModule } from '@nestjs/config';
import { DataLoaderModule } from '../loaders/data-loader.module';

@Module({
  imports: [
    forwardRef(() => AuthModule),
    PrismaModule,
    ConfigModule,
    DataLoaderModule,
  ],
  providers: [UserResolver, UserService],
  exports: [UserResolver, UserService],
})
export class UserModule {}

// ====== FILE: src\user\user.resolver.ts ======

import {
  Args,
  Mutation,
  Query,
  Resolver,
  Int,
  ResolveField,
  Parent,
} from '@nestjs/graphql';
import { UseGuards } from '@nestjs/common';
import { User } from './user.model';
import { UserService } from './user.service';
import { Roles } from '../auth/roles.decorator';
import { AuthGuard } from '../auth/auth.guard';
import { UserRole } from './user-role.enum';
import { TeamLoader } from '../loaders/team.loader';
import { Team } from '../team/team.model';
import { PrismaService } from '../prisma/prisma.service';

@Resolver(() => User)
export class UserResolver {
  constructor(
    private userService: UserService,
    private teamLoader: TeamLoader,
    private prisma: PrismaService,
  ) {}

  @Query(() => [User])
  @Roles(UserRole.ADMIN, UserRole.ENABLER)
  @UseGuards(AuthGuard)
  async users(): Promise<User[]> {
    // Only fetch the basic user data without nested relationships
    const users = await this.prisma.user.findMany({
      select: {
        id: true,
        email: true,
        role: true,
      },
    });

    return users.map((user) => ({
      ...user,
      role: UserRole[user.role as keyof typeof UserRole],
    }));
  }

  @ResolveField(() => [Team])
  async teams(@Parent() user: User): Promise<Team[]> {
    // This will be called only when teams field is requested
    // Uses DataLoader to batch and cache the requests
    const teams = await this.teamLoader.byUserId.load(user.id);

    // Map to proper Team model objects with empty projects and rates
    // These will be populated by their own field resolvers if needed
    return teams.map((team) => ({
      ...team,
      projects: [],
      rates: [],
    }));
  }

  @Mutation(() => User)
  @Roles(UserRole.ADMIN)
  @UseGuards(AuthGuard)
  async updateUserRole(
    @Args('userId', { type: () => Int }) userId: number,
    @Args('newRole', { type: () => UserRole }) newRole: UserRole,
  ): Promise<User> {
    const updatedUser = await this.userService.updateUserRole(userId, newRole);
    return {
      ...updatedUser,
      role: UserRole[updatedUser.role as keyof typeof UserRole],
    };
  }

  @Mutation(() => User)
  @Roles(UserRole.ADMIN)
  @UseGuards(AuthGuard)
  async addUserToTeam(
    @Args('userId', { type: () => Int }) userId: number,
    @Args('teamId') teamId: string,
  ): Promise<User> {
    const user = await this.userService.addUserToTeam(userId, teamId);
    return {
      ...user,
      role: UserRole[user.role as keyof typeof UserRole],
    };
  }

  @Mutation(() => User)
  @Roles(UserRole.ADMIN)
  @UseGuards(AuthGuard)
  async removeUserFromTeam(
    @Args('userId', { type: () => Int }) userId: number,
    @Args('teamId') teamId: string,
  ): Promise<User> {
    try {
      const user = await this.userService.removeUserFromTeam(userId, teamId);
      return {
        ...user,
        role: UserRole[user.role as keyof typeof UserRole],
      };
    } catch (error) {
      console.error('Error occurred while removing user from team:', error);
      throw new Error('Error removing user from team');
    }
  }
}

// ====== FILE: src\user\user.service.ts ======

import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { User } from '@prisma/client';
import { UserRole } from '../user/user-role.enum';
import { User as QlUser } from '../user/user.model';

// Local type definitions that don't conflict with Prisma types
type TeamBasic = {
  id: string;
  name: string;
};

type UserTeamDTO = {
  userId: number;
  teamId: string;
  user: {
    id: number;
    email: string;
    password?: string | null;
    role: UserRole;
  };
  team: TeamBasic;
};

@Injectable()
export class UserService {
  private readonly logger = new Logger(UserService.name);

  constructor(private prisma: PrismaService) {}
  async getUserTeams(): Promise<UserTeamDTO[]> {
    const userTeams = await this.prisma.userTeam.findMany({
      include: {
        user: true,
        team: true,
      },
    });

    return userTeams.map((ut) => ({
      userId: ut.userId,
      teamId: ut.teamId,
      user: {
        id: ut.user.id,
        email: ut.user.email,
        role: UserRole[ut.user.role as keyof typeof UserRole],
        password: null,
      },
      team: {
        id: ut.team.id,
        name: ut.team.name,
        // other fields as needed
      },
    }));
  }

  async all(): Promise<QlUser[]> {
    const users = await this.prisma.user.findMany({
      select: {
        id: true,
        email: true,
        role: true,
        teams: {
          select: {
            team: {
              select: {
                id: true,
                name: true,
                projects: {
                  select: {
                    id: true,
                    estimatedTime: true,
                    name: true,
                    teamId: true,
                    createdAt: true,
                    updatedAt: true,
                    description: true,
                    state: true,
                    startDate: true,
                    targetDate: true,
                    // Add any other necessary fields here
                  },
                },
                rates: {
                  select: {
                    id: true,
                    name: true,
                    teamId: true,
                    rate: true,
                    // Add any other necessary fields here
                  },
                },
              },
            },
          },
        },
      },
    });

    return users.map((user) => ({
      id: user.id,
      email: user.email,
      role: UserRole[user.role as keyof typeof UserRole],
      teams: user.teams.map((ut) => ({
        id: ut.team.id,
        name: ut.team.name,
        projects: ut.team.projects, // Now fully populated
        rates: ut.team.rates, // Now fully populated
      })),
    }));
  }

  async findOne(email: string): Promise<User | undefined> {
    const user = await this.prisma.user.findFirst({
      where: {
        email,
      },
    });

    if (user) {
      return {
        ...user,
        role: UserRole[user.role as keyof typeof UserRole],
      };
    }

    return undefined;
  }

  async create(
    email: string,
    hashedPassword: string,
    role: UserRole,
  ): Promise<User> {
    return this.prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        role,
      },
    });
  }

  async count(): Promise<number> {
    return this.prisma.user.count();
  }

  async updateUserRole(userId: number, newRole: UserRole): Promise<User> {
    const updatedUser = await this.prisma.user.update({
      where: {
        id: userId,
      },
      data: {
        role: newRole,
      },
    });

    return {
      ...updatedUser,
      role: UserRole[updatedUser.role as keyof typeof UserRole],
    };
  }

  async addUserToTeam(userId: number, teamId: string): Promise<User> {
    return this.prisma.$transaction(async (tx) => {
      // First, check if the user and team exist
      const userExists = await tx.user.findUnique({
        where: { id: userId },
      });
      const teamExists = await tx.team.findUnique({
        where: { id: teamId },
      });

      if (!userExists || !teamExists) {
        throw new Error('User or Team not found');
      }

      // Check if the relation already exists
      const existingRelation = await tx.userTeam.findUnique({
        where: {
          userId_teamId: {
            userId,
            teamId,
          },
        },
      });

      // If the relation does not exist, create it
      if (!existingRelation) {
        await tx.userTeam.create({
          data: {
            userId,
            teamId,
          },
        });
      }

      // Get the updated user with teams within the transaction
      const user = await tx.user.findUnique({
        where: { id: userId },
        include: {
          teams: {
            include: {
              team: {
                include: {
                  projects: true,
                  rates: true,
                },
              },
            },
          },
        },
      });

      if (!user) {
        throw new Error(
          `User with ID ${userId} not found after adding to team`,
        );
      }

      return user;
    });
  }

  private async getUserWithTeams(userId: number): Promise<any> {
    return this.prisma.user.findUnique({
      where: { id: userId },
      include: {
        teams: {
          include: {
            team: {
              include: {
                projects: true,
                rates: true,
              },
            },
          },
        },
      },
    });
  }

  async removeUserFromTeam(userId: number, teamId: string): Promise<User> {
    this.logger.debug(
      `Removing user ${userId} from team ${teamId}. First, logging current state.`,
    );

    try {
      // Get current state
      const userBefore = await this.getUserWithTeams(userId);
      this.logger.debug(
        `Current state - User ${userId} has ${
          userBefore?.teams?.length || 0
        } teams`,
      );

      // Use a transaction to ensure the operation is atomic
      return await this.prisma.$transaction(async (tx) => {
        // Perform the disconnection
        await tx.userTeam.deleteMany({
          where: {
            userId: userId,
            teamId: teamId,
          },
        });

        // Get the updated user data
        const updatedUser = await this.getUserWithTeams(userId);
        this.logger.debug(
          `After removal - User ${userId} now has ${
            updatedUser?.teams?.length || 0
          } teams`,
        );

        return updatedUser;
      });
    } catch (error) {
      this.logger.error(
        `Failed to remove user ${userId} from team ${teamId}:`,
        error,
      );
      throw error;
    }
  }
}

// ====== FILE: src\webhook\webhook.controller.ts ======

import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { WebhookService } from './webhook.service';
import { WebhookGuard } from './webhook.guard';

@Controller('webhook')
export class WebhookController {
  constructor(private webhookService: WebhookService) {}

  @Post()
  @UseGuards(WebhookGuard)
  async handle(@Body() body: any) {
    await this.webhookService.handle(body);
  }
}

// ====== FILE: src\webhook\webhook.guard.ts ======

import {
  Injectable,
  CanActivate,
  ExecutionContext,
  Logger,
  UnauthorizedException,
} from '@nestjs/common';
import * as crypto from 'crypto';

@Injectable()
export class WebhookGuard implements CanActivate {
  private readonly logger = new Logger(WebhookGuard.name);

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const linearSignature = request.headers['linear-signature'];
    const webhookSecret = process.env.WEBHOOK_SECRET || '';

    if (!linearSignature) {
      this.logger.warn('Missing Linear signature header');
      throw new UnauthorizedException('Missing Linear signature header');
    }

    this.logger.debug(`recevived Linear signature: ${linearSignature}`);
    this.logger.debug(
      `Webhook secret available: ${!!process.env.WEBHOOK_SECRET}`,
    );

    if (!webhookSecret) {
      this.logger.error('Webhook secret not configured');
      return false;
    }

    const payload = JSON.stringify(request.body);

    const signature = crypto
      .createHmac('sha256', process.env.WEBHOOK_SECRET || '')
      .update(payload)
      .digest('hex');

    this.logger.debug(`Calculated signature: ${signature}`);

    try {
      const isValid = signature === linearSignature;

      if (!isValid) {
        this.logger.warn('Signature mismatch - webhook validation failed');
        throw new UnauthorizedException('Invalid webhook signature');
      }

      return true;
    } catch (error) {
      this.logger.error('Error validating webhook signature', error);
      throw new UnauthorizedException('Error validating webhook signature');
    }
  }
}

// ====== FILE: src\webhook\webhook.issue.service.ts ======

import { Injectable, Logger } from '@nestjs/common';
import { IssueWebhookData, LinearWebhookBody } from './webhook.service';
import { IssueService } from '../issue/issue.service';
import { PrismaClient } from '@prisma/client';
import { IssueUpdatesGateway } from '../issue-updates/issue-updates.gateway';

const prisma = new PrismaClient();

@Injectable()
export class WebhookIssueService {
  private readonly logger = new Logger(WebhookIssueService.name);
  constructor(
    private issueService: IssueService,
    private readonly issueUpdatesGateway: IssueUpdatesGateway,
  ) {}

  async handleIssue(json: LinearWebhookBody) {
    if (json.type !== 'Issue') {
      console.error('Expected issue data, received:', json.type);
      return;
    }

    const issueData = json.data as IssueWebhookData;

    try {
      switch (json.action) {
        case 'create':
          console.log(`Processing issue create webhook for: ${issueData.id}`);

          const hasProjectForCreate = await this.ensureProjectId(issueData);
          if (!hasProjectForCreate) {
            console.warn(
              `Cannot create issue ${issueData.id}: No suitable project found`,
            );
            return;
          }

          await prisma.$transaction(async (tx) => {
            const createdIssue = await this.createIssue(issueData);

            // Also update labels for newly created issue
            if (issueData.labels && issueData.labels.length > 0) {
              await this.issueService.updateLabelsForIssue(
                issueData.id,
                issueData.labels,
              );
            }

            this.issueUpdatesGateway.broadcastIssueUpdate(createdIssue);
          });

          break;

        case 'update':
          console.log(`Processing issue update webhook for: ${issueData.id}`);

          await prisma.$transaction(async (tx) => {
            // Check if the issue exists before trying to update
            const existingIssue = await prisma.issue.findUnique({
              where: { id: issueData.id },
              select: { id: true },
            });

            if (existingIssue) {
              // If issue exists, we can update it even without a projectId
              await this.updateExistingIssue(issueData);

              // Then update its labels if present
              if (issueData.labels) {
                await this.issueService.updateLabelsForIssue(
                  issueData.id,
                  issueData.labels,
                );
              }
            } else {
              // Issue doesn't exist, need projectId for creation
              const hasProjectForUpdate = await this.ensureProjectId(issueData);
              if (!hasProjectForUpdate) {
                console.warn(
                  `Cannot create non-existent issue ${issueData.id} via update: Missing projectId and no suitable default found`,
                );
                return; // Skip further processing
              }

              await this.createIssue(issueData);

              if (issueData.labels && issueData.labels.length > 0) {
                await this.issueService.updateLabelsForIssue(
                  issueData.id,
                  issueData.labels,
                );
              }
            }

            const updatedIssue = await this.updateExistingIssue(issueData);
            this.issueUpdatesGateway.broadcastIssueUpdate(updatedIssue);
          });
          break;

        case 'remove':
          console.log(`Processing issue remove webhook for: ${issueData.id}`);

          await prisma.$transaction(async (tx) => {
            await this.issueService.remove(issueData.id);

            this.issueUpdatesGateway.broadcastIssueUpdate({
              id: issueData.id,
              action: 'remove',
            }); // Broadcast remove event, send minimal info
          });
          break;

        default:
          console.log('Unhandled webhook action:', json.action);
      }
    } catch (error) {
      if (error.message.includes('Missing projectId')) {
        console.warn(
          `Could not process issue ${issueData.id}: Missing projectId. This might be a standalone issue not connected to any project.`,
        );
      } else {
        console.error(
          `Error processing webhook for issue ${issueData.id}:`,
          error.message,
        );
      }
    }
  }

  private async ensureProjectId(data: IssueWebhookData): Promise<boolean> {
    // Try to get projectId from project.id if projectId is missing
    if (!data.projectId && data.project?.id) {
      data.projectId = data.project.id;
      return true;
    }

    // If still no projectId, try to find a default project
    if (!data.projectId) {
      try {
        // First attempt: Try to find a project associated with the team if available
        if (data.team?.id) {
          const teamProject = await prisma.project.findFirst({
            where: { teamId: data.team.id },
            select: { id: true, name: true },
            orderBy: { createdAt: 'desc' },
          });

          if (teamProject) {
            console.log(
              `Using team's project: ${teamProject.name} (${teamProject.id}) for issue ${data.id}`,
            );
            data.projectId = teamProject.id;
            data.projectName = teamProject.name;
            return true;
          }
        }

        // Second attempt: Try to find any available project
        const anyProject = await prisma.project.findFirst({
          select: { id: true, name: true },
          orderBy: { createdAt: 'desc' },
        });

        if (anyProject) {
          console.log(
            `Using default project: ${anyProject.name} (${anyProject.id}) for issue ${data.id}`,
          );
          data.projectId = anyProject.id;
          data.projectName = anyProject.name;
          return true;
        }

        const unassignedProject = await this.createOrGetUnassignedProject();
        if (unassignedProject) {
          console.log(`Using "Unassigned" project for issue ${data.id}`);
          data.projectId = unassignedProject.id;
          data.projectName = unassignedProject.name;
          return true;
        }

        // If we reach here, we couldn't find or create a suitable project
        console.warn(`Could not find any project for issue ${data.id}`);
        return false;
      } catch (error) {
        console.error(`Error finding default project: ${error.message}`);
        return false;
      }
    }

    return true;
  }

  // Helper method to create or get an "Unassigned" project
  private async createOrGetUnassignedProject() {
    const UNASSIGNED_PROJECT_ID = 'unassigned-project-id'; // Use a fixed ID

    try {
      // Try to find existing unassigned project
      const existingProject = await prisma.project.findUnique({
        where: { id: UNASSIGNED_PROJECT_ID },
      });

      if (existingProject) {
        return existingProject;
      }

      // Create unassigned project if it doesn't exist
      return await prisma.$transaction(async (tx) => {
        // First need to make sure there's at least one team
        const team = await tx.team.findFirst();
        if (!team) {
          console.error('Cannot create unassigned project: No teams exist');
          return null;
        }

        // Create the project
        return await tx.project.create({
          data: {
            id: UNASSIGNED_PROJECT_ID,
            name: 'Unassigned',
            teamId: team.id,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            state: 'Unassigned',
            description: 'Automatically created for issues without projects',
          },
        });
      });
    } catch (error) {
      console.error(`Error creating unassigned project: ${error.message}`);
      return null;
    }
  }

  private async createIssue(data: IssueWebhookData) {
    try {
      // Ensure we have a projectId
      if (!this.ensureProjectId(data)) {
        throw new Error(
          `Issue ${data.id} has no projectId and no default project is available`,
        );
      }

      return await this.issueService.create(data);
    } catch (error) {
      console.error(`Failed to create issue ${data.id}:`, error.message);
      throw error;
    }
  }

  private async updateExistingIssue(data: IssueWebhookData) {
    try {
      const updateData: any = {
        updatedAt: data.updatedAt,
        title: data.title,
        dueDate: data.dueDate,
        priorityLabel: data.priorityLabel || 'No Priority',
        identifier: data.identifier,
        assigneeName: data.assignee?.name || 'No Assignee',
        state: data.state?.name,
        teamName: data.team?.name,
      };

      // Only include projectName and projectId if they exist
      if (data.project?.name) {
        updateData.projectName = data.project.name;
      }

      if (data.projectId) {
        updateData.projectId = data.projectId;
      }

      // Handle team relationship
      if (data.team?.id) {
        updateData.teamKey = data.team.id;
      }

      // Update the issue directly using prisma to avoid the create fallback
      await prisma.issue.update({
        where: { id: data.id },
        data: updateData,
      });

      return { id: data.id };
    } catch (error) {
      console.error(
        `Failed to update existing issue ${data.id}:`,
        error.message,
      );
      throw error;
    }
  }

  private async updateIssue(data: IssueWebhookData) {
    try {
      // Try to get projectId from project.id if projectId is missing
      this.ensureProjectId(data);

      return await this.issueService.update(data.id, data);
    } catch (error) {
      console.error(`Failed to update issue ${data.id}:`, error.message);
      throw error;
    }
  }
}

// ====== FILE: src\webhook\webhook.module.ts ======

import { Module } from '@nestjs/common';
import { WebhookService } from './webhook.service';
import { WebhookController } from './webhook.controller';
import { WebhookProjectService } from './webhook.project.service';
import { ProjectService } from '../project/project.service';
import { WebhookIssueService } from './webhook.issue.service';
import { IssueService } from '../issue/issue.service';
import { TeamModule } from '../team/team.module';
import { IssueUpdatesModule } from '../issue-updates/issue-updates.module';
import { PrismaModule } from '../prisma/prisma.module';
import { DatabaseSyncModule } from '../dbSynch/dbSynch.module';
@Module({
  imports: [TeamModule, IssueUpdatesModule, PrismaModule, DatabaseSyncModule],
  providers: [
    ProjectService,
    WebhookService,
    WebhookProjectService,
    IssueService,
    WebhookIssueService,
  ],
  controllers: [WebhookController],
})
export class WebhookModule {}

// ====== FILE: src\webhook\webhook.project.service.ts ======

import { Injectable } from '@nestjs/common';
import { ProjectWebhookData, LinearWebhookBody } from './webhook.service';
import { ProjectService } from '../project/project.service';

@Injectable()
export class WebhookProjectService {
  constructor(private projectService: ProjectService) {}

  async handleProject(json: LinearWebhookBody) {
    if (json.type !== 'Project') {
      console.error('Expected project data, received:', json.type);
      return;
    }
    switch (json.action) {
      case 'create':
        await this.create(json.data);
        break;
      case 'remove':
        await this.remove(json.data);
        break;
      case 'update':
        await this.update(json.data);
        break;
      default:
        console.log('UNMATCHED WEBHOOK FROM LINEAR');
        break;
    }
  }

  async create(json: LinearWebhookBody['data']) {
    const projectData = json as ProjectWebhookData;
    await this.projectService.create(
      projectData.id,
      projectData.name,
      projectData.teamIds[0],
      projectData.createdAt,
      projectData.updatedAt,
      projectData.description,
      projectData.state || 'Active',
      projectData.startDate,
      projectData.targetDate,
    );
  }

  async remove(json: LinearWebhookBody['data']) {
    await this.projectService.remove(json.id);
  }

  async update(json: LinearWebhookBody['data']) {
    const projectData = json as ProjectWebhookData;
    await this.projectService.update(
      projectData.id,
      projectData.name,
      projectData.teamIds[0],
      projectData.createdAt,
      projectData.updatedAt,
      projectData.description,
      projectData.state || 'Active',
      projectData.startDate,
      projectData.targetDate,
    );
  }
}

// ====== FILE: src\webhook\webhook.service.ts ======

import { Injectable, Logger } from '@nestjs/common';
import { WebhookProjectService } from './webhook.project.service';
import { WebhookIssueService } from './webhook.issue.service';
import { TeamService } from '../team/team.service';
import { DatabaseSyncService } from '../dbSynch/dbSynch.service';

export type ProjectWebhookData = {
  id: string;
  name: string;
  teamIds: string[];
  createdAt: string;
  updatedAt: string;
  description: string;
  state: string;
  startDate: string;
  targetDate: string;
};

export type IssueWebhookData = {
  id: string;
  createdAt: string;
  updatedAt: string;
  title: string;
  dueDate: string;
  projectId: string;
  priorityLabel: string;
  identifier: string;
  assignee?: {
    id: string;
    name: string;
  };
  project?: {
    id: string;
    name: string;
  };
  state?: {
    id: string;
    color: string;
    name: string;
    type: string;
  };
  team?: {
    id: string;
    key: string;
    name: string;
  };
  labels?: Array<{ id: string; name: string; color: string; parentId: string }>;
  projectName?: string;
};

export type LinearWebhookBody = {
  action: 'create' | 'remove' | 'update';
  data: ProjectWebhookData | IssueWebhookData;
  type: 'Project' | 'Issue';
};

@Injectable()
export class WebhookService {
  private readonly logger = new Logger(WebhookService.name);

  constructor(
    private webhookProjectService: WebhookProjectService,
    private webhookIssueService: WebhookIssueService,
    private teamService: TeamService,
    private databaseSyncService: DatabaseSyncService,
  ) {}

  async handle(json: LinearWebhookBody) {
    if (json.type == 'Project') {
      const projectData = json.data as ProjectWebhookData;
      const teamId = projectData.teamIds[0];
      // Check if the team associated with the project exists
      const team = await this.teamService.getTeamById(teamId);
      if (!team) {
        // Synchronize teams using the LinearService
        this.logger.log('Team not found. Synchronizing from Linear.');

        await this.databaseSyncService.synchronizeTeamsOnly();

        // Re-check if the team is now present after synchronization
        const synchronizedTeam = await this.teamService.getTeamById(teamId);
        if (!synchronizedTeam) {
          this.logger.error(
            'Team still not found after synchronization. Cannot process project.',
          );
          return;
        }
      }
      await this.webhookProjectService.handleProject(json);
    } else if (json.type === 'Issue') {
      await this.webhookIssueService.handleIssue(json);
    }
  }
}

// ====== FILE: src\auth\dto\auth-response.ts ======

import { Field, ObjectType } from '@nestjs/graphql';
import { UserProfileDto } from './user-profile.dto';

@ObjectType()
export class AuthResponse {
  @Field(() => String)
  access_token: string;

  @Field(() => UserProfileDto, { nullable: true })
  user?: UserProfileDto;
}

// ====== FILE: src\auth\dto\logout-response.ts ======

import { Field, ObjectType } from '@nestjs/graphql';

@ObjectType()
export class LogoutResponse {
  @Field(() => Boolean)
  success: boolean;
}

// ====== FILE: src\auth\dto\refresh-token-response.ts ======

// src/auth/dto/refresh-token-response.ts
import { Field, ObjectType } from '@nestjs/graphql';

@ObjectType()
export class RefreshTokenResponse {
  @Field(() => String) // Specify String type for GraphQL
  access_token: string;
}

// ====== FILE: src\auth\dto\sign-in.input.ts ======

import { Field, InputType } from '@nestjs/graphql';
import { IsEmail, IsNotEmpty, IsString, MinLength } from 'class-validator';

@InputType()
export class SignInInput {
  @Field()
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @Field()
  @IsString()
  @IsNotEmpty()
  @MinLength(6)
  password: string;
}

// ====== FILE: src\auth\dto\sign-up.input.ts ======

import { Field, InputType } from '@nestjs/graphql';
import { IsEmail, IsNotEmpty, IsString, MinLength } from 'class-validator';

@InputType()
export class SignUpInput {
  @Field()
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @Field()
  @IsString()
  @IsNotEmpty()
  @MinLength(6)
  password: string;
}

// ====== FILE: src\auth\dto\user-profile.dto.ts ======

import { Exclude, Expose } from 'class-transformer';
import { UserRole } from '../../user/user-role.enum';
import { Field, ObjectType, Int } from '@nestjs/graphql';

@ObjectType()
@Exclude()
export class UserProfileDto {
  @Field(() => Int)
  @Expose()
  id: number;

  @Field()
  @Expose()
  email: string;

  @Field(() => UserRole)
  @Expose()
  role: UserRole;

  constructor(partial: UserProfileDto) {
    Object.assign(this, partial);
  }
}

// ====== FILE: src\dbSynch\dto\sync-response.ts ======

import { Field, ObjectType } from '@nestjs/graphql';

@ObjectType()
export class SyncResponse {
  @Field()
  status: string;

  @Field()
  message: string;

  @Field()
  timestamp: string;
}
