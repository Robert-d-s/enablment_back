// ====== FILE: .eslintrc.js ======

module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};

// ====== FILE: nest-cli.json ======

{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

// ====== FILE: package.json ======

{
  "name": "et-backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@apollo/server": "^4.7.1",
    "@nestjs/apollo": "^11.0.5",
    "@nestjs/axios": "^3.0.1",
    "@nestjs/common": "^9.0.0",
    "@nestjs/config": "^2.3.1",
    "@nestjs/core": "^9.0.0",
    "@nestjs/graphql": "^11.0.5",
    "@nestjs/jwt": "^10.0.3",
    "@nestjs/platform-express": "^9.0.0",
    "@nestjs/platform-socket.io": "^9.4.3",
    "@nestjs/websockets": "^9.4.3",
    "@prisma/client": "^4.13.0",
    "bcrypt": "^5.1.0",
    "graphql": "^16.6.0",
    "graphql-ws": "^5.14.3",
    "micro": "^10.0.1",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.2.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^9.0.0",
    "@nestjs/schematics": "^9.0.0",
    "@nestjs/testing": "^9.0.0",
    "@types/express": "^4.17.13",
    "@types/jest": "29.2.4",
    "@types/node": "18.11.18",
    "@types/supertest": "^2.0.11",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.0.1",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "29.3.1",
    "prettier": "^2.3.2",
    "prisma": "^4.13.0",
    "source-map-support": "^0.5.20",
    "supertest": "^6.1.3",
    "ts-jest": "29.0.3",
    "ts-loader": "^9.2.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "4.1.1",
    "typescript": "^4.7.4",
    "webpack": "^5.88.2"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

// ====== FILE: tsconfig.build.json ======

{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

// ====== FILE: tsconfig.json ======

{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2017",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}

// ====== FILE: prisma\schema.prisma ======

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id       Int    @id @default(autoincrement())
  email    String @unique
  password String

  role UserRole @default(PENDING)

  times Time[]
  teams UserTeam[]
}

enum UserRole {
  ADMIN
  ENABLER
  COLLABORATOR
  PENDING
}

model UserTeam {
  userId Int
  teamId String
  user   User   @relation(fields: [userId], references: [id])
  team   Team   @relation(fields: [teamId], references: [id])

  @@id([userId, teamId])
}

model Team {
  id   String @id
  name String

  users    UserTeam[]
  projects Project[]
  rates    Rate[]
  issues   Issue[]
}

model Rate {
  id     Int    @id @default(autoincrement())
  name   String
  teamId String
  rate   Int

  team  Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  times Time[]
}

model Project {
  id            String  @id
  estimatedTime Int?
  name          String
  teamId        String
  createdAt     String
  updatedAt     String
  description   String?
  state         String
  startDate     String?
  targetDate    String?

  time Time[]

  issues Issue[]
  team   Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model Time {
  id               Int       @id @default(autoincrement())
  startTime        DateTime
  endTime          DateTime?
  userId           Int
  projectId        String
  rateId           Int?
  totalElapsedTime Int

  user    User    @relation(fields: [userId], references: [id])
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  rate    Rate?   @relation(fields: [rateId], references: [id])
}

model Issue {
  id            String  @id
  createdAt     String
  updatedAt     String
  title         String
  dueDate       String?
  projectId     String
  priorityLabel String
  identifier    String
  assigneeName  String?
  projectName   String
  state         String
  teamKey       String?
  teamName      String?

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  team    Team?   @relation(fields: [teamKey], references: [id], onDelete: SetNull)
  labels  Label[]
}

model Label {
  id       String
  color    String
  name     String
  parentId String?
  issueId  String

  issue      Issue @relation(fields: [issueId], references: [id], onDelete: Cascade)
  internalId Int   @id @default(autoincrement())

  @@index([id, issueId], name: "idx_label_issue")
}

// ====== FILE: src\app.controller.ts ======

import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

// ====== FILE: src\app.module.ts ======

import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AuthModule } from './auth/auth.module';
import { UserModule } from './user/user.module';
import { ConfigModule } from '@nestjs/config';
import { GraphQLModule } from '@nestjs/graphql';
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';
import { WebhookModule } from './webhook/webhook.module';
import { ProjectModule } from './project/project.module';
import { IssueModule } from './issue/issue.module';
import { TeamModule } from './team/team.module';
import { RateModule } from './rate/rate.module';
import { TimeModule } from './time/time.module';
import { InvoiceModule } from './invoice/invoice.module';
import { DatabaseSyncModule } from './dbSynch/dbSynch.module';
import { HttpModule } from '@nestjs/axios';
import { IssueUpdatesModule } from './issue-updates/issue-updates.module';
import { PrismaModule } from './prisma/prisma.module';

@Module({
  imports: [
    ConfigModule.forRoot(),
    AuthModule,
    UserModule,
    ProjectModule,
    IssueModule,
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      autoSchemaFile: './schema.graphql',
      context: ({ req }) => ({ req }),
    }),
    WebhookModule,
    TeamModule,
    RateModule,
    TimeModule,
    InvoiceModule,
    DatabaseSyncModule,
    HttpModule,
    IssueUpdatesModule,
    PrismaModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

// ====== FILE: src\app.service.ts ======

import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

// ====== FILE: src\main.ts ======

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.enableCors({
    origin: '*',
  });

  await app.listen(process.env.PORT || 8080);
  console.log(`Server is running on http://localhost:8080/graphql`);
}

bootstrap();

// ====== FILE: src\repl.ts ======

import { repl } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  await repl(AppModule);
}
bootstrap();

// ====== FILE: test\app.e2e-spec.ts ======

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

// describe('AppController (e2e)', () => {
//   let app: INestApplication;

//   beforeEach(async () => {
//     const moduleFixture: TestingModule = await Test.createTestingModule({
//       imports: [AppModule],
//     }).compile();

//     app = moduleFixture.createNestApplication();
//     await app.init();
//   });

//   it('/ (GET)', () => {
//     return request(app.getHttpServer())
//       .get('/')
//       .expect(200)
//       .expect('Hello World!');
//   });
// });

describe('AppController (e2e)', () => {
  let app: INestApplication;
  let jwtToken: string;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    // Login and get JWT token
    const response = await request(app.getHttpServer())
      .post('/auth/login')
      .send({
        email: 'rs@enablment.com',
        password: 'Oldschool!',
      });

    jwtToken = response.body.access_token;
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .set('Authorization', `Bearer ${jwtToken}`)
      .expect(200)
      .expect('Hello World!');
  });
});

// ====== FILE: test\jest-e2e.json ======

{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

// ====== FILE: src\auth\auth.controller.ts ======

import {
  Body,
  Controller,
  Post,
  HttpCode,
  HttpStatus,
  Request,
  Get,
  SetMetadata,
} from '@nestjs/common';
import { AuthService } from './auth.service';

export const Public = () => SetMetadata('isPublic', true);

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  @Public()
  signIn(@Body() signInDto: Record<string, any>) {
    return this.authService.signIn(signInDto.email, signInDto.password);
  }

  @Post('signup')
  @Public()
  signUp(@Body() signUpDto: Record<string, string>) {
    return this.authService.signUp(signUpDto.email, signUpDto.password);
  }

  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}

// ====== FILE: src\auth\auth.guard.ts ======

import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
  ForbiddenException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { jwtConstants } from './constants';
import { Request } from 'express';
import { IS_PUBLIC_KEY } from './auth.module';
import { Reflector } from '@nestjs/core';

import { UserService } from '../user/user.service';
import { UserRole } from '@prisma/client';
import { GqlExecutionContext } from '@nestjs/graphql';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private reflector: Reflector,
    private userService: UserService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // Check if the route is public
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) {
      return true;
    }

    const ctx = context.switchToHttp();
    const graphqlCtx = GqlExecutionContext.create(context);
    const request = ctx.getRequest<Request>() || graphqlCtx.getContext().req;

    if (!request) {
      throw new UnauthorizedException('No request found');
    }
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      throw new UnauthorizedException('No token found in request headers');
    }

    try {
      // Verify the token
      const payload = await this.jwtService.verifyAsync(token, {
        secret: jwtConstants.secret,
      });
      console.log('auth payload contains', payload);
      request['user'] = payload;

      // Check for roles
      return await this.checkUserRoles(context, payload.email);
    } catch (error) {
      // Enhance and rethrow the error with custom error information
      if (error instanceof UnauthorizedException) {
        throw new UnauthorizedException({
          message: error.message,
          code: 'UNAUTHORIZED', // Custom error code
        });
      }
      if (error instanceof ForbiddenException) {
        throw new ForbiddenException({
          message: error.message,
          code: 'FORBIDDEN', // Custom error code
        });
      }
      // If it's not one of the above exceptions, rethrow the original error
      throw error;
    }
  }

  private async checkUserRoles(
    context: ExecutionContext,
    userEmail: string,
  ): Promise<boolean> {
    const requiredRoles = this.reflector.get<UserRole[]>(
      'roles',
      context.getHandler(),
    );
    if (!requiredRoles) {
      return true; // No specific roles required
    }

    const user = await this.userService.findOne(userEmail);
    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    if (!requiredRoles.includes(user.role)) {
      throw new ForbiddenException(
        'Insufficient permissions to access this resource',
      );
    }

    return true; // User has the required role
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    if (!request || !request.headers.authorization) {
      return undefined;
    }
    const [type, token] = request.headers.authorization.split(' ');
    return type === 'Bearer' ? token : undefined;
  }
}

// ====== FILE: src\auth\auth.module.ts ======

import { Module, forwardRef } from '@nestjs/common';
import { AuthService } from './auth.service';
import { JwtModule } from '@nestjs/jwt';
import { AuthController } from './auth.controller';
// import { jwtConstants } from './constants';
import { UserModule } from '../user/user.module';
import { APP_GUARD } from '@nestjs/core';
import { AuthGuard } from './auth.guard';

import { ConfigModule, ConfigService } from '@nestjs/config';

export const IS_PUBLIC_KEY = 'isPublic';

@Module({
  imports: [
    ConfigModule,
    forwardRef(() => UserModule),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'), // âœ… Load from env correctly
        signOptions: { expiresIn: '43200s' },
      }),
    }),
  ],
  providers: [
    AuthService,
    {
      provide: APP_GUARD,
      useClass: AuthGuard,
    },
  ],
  controllers: [AuthController],
  exports: [AuthService, JwtModule],
})
export class AuthModule {}

// ====== FILE: src\auth\auth.service.ts ======

import {
  Injectable,
  UnauthorizedException,
  ConflictException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UserService } from '../user/user.service';

import { User } from '@prisma/client';
import { UserRole } from '../user/user-role.enum';

import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private userService: UserService,
    private jwtService: JwtService,
  ) {}

  async signIn(username, pass) {
    const user = await this.userService.findOne(username);

    // Check if the user exists
    if (!user) {
      throw new UnauthorizedException({ error: 'Invalid email or password.' });
    }

    // Check if the password is correct
    if (!bcrypt.compareSync(pass, user.password)) {
      throw new UnauthorizedException({ error: 'Invalid email or password.' });
    }

    const payload = { email: user.email, id: user.id };
    return {
      access_token: await this.jwtService.signAsync(payload),
    };
  }

  async signUp(email: string, password: string): Promise<User> {
    const userCount = await this.userService.count();
    const role = userCount === 0 ? UserRole.ADMIN : UserRole.PENDING;

    if (userCount > 0) {
      const existingUser = await this.userService.findOne(email);
      if (existingUser) {
        throw new ConflictException('Email already exists.');
      }
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    return this.userService.create(email, hashedPassword, role);
  }
}

// ====== FILE: src\auth\constants.ts ======

export const jwtConstants = {
  secret: process.env.JWT_SECRET,
};

// ====== FILE: src\auth\roles.decorator.ts ======

import { SetMetadata } from '@nestjs/common';
import { UserRole } from '@prisma/client';

export const Roles = (...roles: UserRole[]) => SetMetadata('roles', roles);

// ====== FILE: src\dbSynch\dbSynch.controller.ts ======

import { Controller, Get, HttpCode, Logger } from '@nestjs/common';
import { DatabaseSyncService } from './dbSynch.service';

@Controller('database-sync')
export class DatabaseSyncController {
  private readonly logger = new Logger(DatabaseSyncController.name);

  constructor(private readonly databaseSyncService: DatabaseSyncService) {}

  @Get('/full')
  @HttpCode(200)
  async synchronizeDatabase() {
    this.logger.log('Full database synchronization requested');
    try {
      await this.databaseSyncService.synchronizeDatabase();
      return {
        status: 'success',
        message: 'Database synchronization completed successfully',
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      this.logger.error(`Synchronization failed: ${error.message}`);
      return {
        status: 'error',
        message: `Synchronization failed: ${error.message}`,
        timestamp: new Date().toISOString(),
      };
    }
  }
}

// ====== FILE: src\dbSynch\dbSynch.module.ts ======

import { Module } from '@nestjs/common';
import { DatabaseSyncService } from './dbSynch.service';
import { DatabaseSyncController } from './dbSynch.controller';
import { HttpModule } from '@nestjs/axios';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [HttpModule, ConfigModule],
  providers: [DatabaseSyncService],
  controllers: [DatabaseSyncController],
  exports: [DatabaseSyncService],
})
export class DatabaseSyncModule {}

// ====== FILE: src\dbSynch\dbSynch.service.ts ======

import { Injectable, Logger } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
import { HttpService } from '@nestjs/axios';
import { ConfigService } from '@nestjs/config';
import { firstValueFrom } from 'rxjs';

const prisma = new PrismaClient({
  log: ['error'],
});

@Injectable()
export class DatabaseSyncService {
  private readonly logger = new Logger(DatabaseSyncService.name);
  private linearApiKey: string;

  constructor(
    private readonly httpService: HttpService,
    private readonly configService: ConfigService,
  ) {
    this.linearApiKey = this.configService.get<string>('LINEAR_KEY');

    if (!this.linearApiKey) {
      this.logger.error('LINEAR_KEY not found in environment');
    }
  }

  async synchronizeDatabase(): Promise<void> {
    this.logger.log('Starting comprehensive database synchronization');

    try {
      // Use a transaction to ensure atomicity
      await prisma.$transaction(async (tx) => {
        // 1. Synchronize teams from Linear
        await this.synchronizeTeams(tx);

        // 2. Synchronize projects from Linear
        await this.synchronizeProjects(tx);

        // 3. Synchronize issues from Linear
        await this.synchronizeIssues(tx);

        // 4. Clean up orphaned records
        await this.cleanupOrphanedRecords(tx);
      });

      this.logger.log('Database synchronization completed successfully');
    } catch (error) {
      this.logger.error(
        `Database synchronization failed: ${error.message}`,
        error.stack,
      );
      throw new Error(`Synchronization failed: ${error.message}`);
    }
  }

  /**
   * Fetch data from Linear GraphQL API
   */
  private async fetchFromLinear(query: string, variables = {}): Promise<any> {
    try {
      this.logger.debug(
        `Sending query to Linear API: ${query.substring(0, 100)}...`,
      );
      this.logger.debug(`With variables: ${JSON.stringify(variables)}`);

      // Check if API key is present
      if (!this.linearApiKey) {
        throw new Error('LINEAR_KEY is not configured');
      }

      // Make the request with proper error handling
      const response = await firstValueFrom(
        this.httpService.post(
          'https://api.linear.app/graphql',
          { query, variables },
          {
            headers: {
              'Content-Type': 'application/json',
              Authorization: this.linearApiKey, // Make sure this is a bearer token if required
            },
            timeout: 10000,
          },
        ),
      );

      // Check for GraphQL errors
      if (response.data.errors) {
        const errorMsg = response.data.errors.map((e) => e.message).join(', ');
        this.logger.error(`GraphQL errors: ${errorMsg}`);
        throw new Error(`GraphQL errors: ${errorMsg}`);
      }

      return response.data.data;
    } catch (error) {
      // Log the detailed error
      if (error.response) {
        // The request was made and the server responded with a status code
        this.logger.error(
          `Linear API Error - Status: ${error.response.status}`,
        );
        this.logger.error(
          `Response data: ${JSON.stringify(error.response.data)}`,
        );
      } else if (error.request) {
        // The request was made but no response was received
        this.logger.error('Linear API Error - No response received');
      } else {
        // Something happened in setting up the request
        this.logger.error(`Linear API Error - Setup: ${error.message}`);
      }

      throw error;
    }
  }

  /**
   * Synchronize teams from Linear
   */
  public async synchronizeTeams(tx: any): Promise<void> {
    this.logger.log('Fetching teams from Linear');

    const query = `
      query {
        teams {
          nodes {
            id
            name
            key
          }
        }
      }
    `;

    try {
      const data = await this.fetchFromLinear(query);
      const teams = data.teams.nodes;

      this.logger.log(`Processing ${teams.length} teams from Linear`);

      // Get existing teams from database
      const allTeamsInDb = await tx.team.findMany({
        select: { id: true, name: true },
      });

      const teamsToDelete = new Set(allTeamsInDb.map((team) => team.id));

      // Update or create teams
      for (const teamData of teams) {
        await tx.team.upsert({
          where: { id: teamData.id },
          update: { name: teamData.name },
          create: { id: teamData.id, name: teamData.name },
        });
        teamsToDelete.delete(teamData.id);
      }

      // Handle teams that don't exist in Linear
      for (const teamId of teamsToDelete) {
        this.logger.warn(`Team ${teamId} no longer exists in Linear`);
        // We don't delete teams here - this will be handled in cleanup phase
      }
    } catch (error) {
      this.logger.error(
        `Error synchronizing teams: ${error.message}`,
        error.stack,
      );
      throw error;
    }
  }
  public async synchronizeTeamsOnly(): Promise<void> {
    this.logger.log('Starting teams-only synchronization');

    try {
      await prisma.$transaction(async (tx) => {
        await this.synchronizeTeams(tx);
      });

      this.logger.log('Teams synchronization completed successfully');
    } catch (error) {
      this.logger.error(
        `Teams synchronization failed: ${error.message}`,
        error.stack,
      );
      throw new Error(`Teams synchronization failed: ${error.message}`);
    }
  }
  /**
   * Synchronize projects from Linear
   */
  /**
   * Synchronize projects from Linear, team by team
   */
  private async synchronizeProjects(tx: any): Promise<void> {
    this.logger.log('Fetching projects from Linear team by team');

    // 1. Fetch all teams first (we need team IDs to query projects for each team)
    const teamsQuery = `
      query {
        teams {
          nodes {
            id
          }
        }
      }
    `;
    const teamsData = await this.fetchFromLinear(teamsQuery);
    const teams = teamsData.teams.nodes;

    this.logger.log(`Fetched ${teams.length} teams to process projects for.`);

    for (const team of teams) {
      let hasNextPage = true;
      let endCursor = null;

      while (hasNextPage) {
        const query = `
            query TeamProjects($teamId: String!, $cursor: String) {
              team(id: $teamId) {
                projects(first: 100, after: $cursor) {
                  pageInfo {
                    hasNextPage
                    endCursor
                  }
                  nodes {
                    id
                    name
                    description
                    state
                    startDate
                    targetDate
                    createdAt
                    updatedAt
                    lead {
                      id
                    }
                    status {
                      id
                      name
                      type
                    }
                  }
                }
              }
            }
          `;

        try {
          const data = await this.fetchFromLinear(query, {
            teamId: team.id, // <--- Pass team ID as variable
            cursor: endCursor,
          });

          if (!data.team || !data.team.projects) {
            this.logger.warn(
              `No projects data returned for team ${team.id}. Skipping page.`,
            );
            hasNextPage = false; // No projects for this team on this page, move to next team
            continue;
          }

          const pageInfo = data.team.projects.pageInfo;
          const projects = data.team.projects.nodes;

          this.logger.log(
            `Processing ${projects.length} projects for team ${team.id} (cursor: ${endCursor})`,
          );

          // Get existing projects from database for this team (optimize if needed)
          const existingProjects = await tx.project.findMany({
            where: { teamId: team.id }, // Filter by team ID
            select: { id: true },
          });
          const existingProjectIds = new Set(existingProjects.map((p) => p.id));

          for (const project of projects) {
            const projectData = {
              id: project.id,
              name: project.name,
              description: project.description || '',
              state: project.state || 'Active',
              createdAt: project.createdAt,
              updatedAt: project.updatedAt,
              startDate: project.startDate || null,
              targetDate: project.targetDate || null,
              teamId: team.id, // <--- Team ID is now correctly set
            };

            await tx.project.upsert({
              where: { id: project.id },
              update: projectData,
              create: projectData,
            });
            existingProjectIds.delete(project.id); // Remove processed project ID
          }

          hasNextPage = pageInfo.hasNextPage;
          endCursor = pageInfo.endCursor;

          if (hasNextPage) {
            await new Promise((resolve) => setTimeout(resolve, 500)); // Rate limit delay
          }
        } catch (error) {
          this.logger.error(
            `Error synchronizing projects for team ${team.id}: ${error.message}`,
            error.stack,
          );
          throw error; // Re-throw to halt transaction
        }
      }
    }
  }

  /**
   * Synchronize issues from Linear
   */
  private async synchronizeIssues(tx: any): Promise<void> {
    this.logger.log('Fetching issues from Linear');

    // We need to query issues with pagination because there could be many
    const pageSize = 100;
    let hasNextPage = true;
    let endCursor = null;
    let processedCount = 0;

    while (hasNextPage) {
      const query = `
        query ($cursor: String) {
          issues(first: ${pageSize}, after: $cursor) {
            pageInfo {
              hasNextPage
              endCursor
            }
            nodes {
              id
              title
              description
              state {
                id
                name
                color
                type
              }
              assignee {
                id
                name
              }
              project {
                id
                name
              }
              team {
                id
                key
                name
              }
              priority
              priorityLabel
              identifier
              dueDate
              createdAt
              updatedAt
              labels {
                nodes {
                  id
                  name
                  color
                }
              }
            }
          }
        }
      `;

      try {
        const data = await this.fetchFromLinear(query, { cursor: endCursor });
        const pageInfo = data.issues.pageInfo;
        const issues = data.issues.nodes;

        processedCount += issues.length;
        this.logger.log(
          `Processing ${issues.length} issues (total: ${processedCount})`,
        );

        // Update pagination info
        hasNextPage = pageInfo.hasNextPage;
        endCursor = pageInfo.endCursor;

        // Process each issue
        for (const issue of issues) {
          // Only process issues with a project
          if (issue.project && issue.team) {
            // Check if the project exists
            const projectExists = await tx.project.findUnique({
              where: { id: issue.project.id },
              select: { id: true },
            });

            if (projectExists) {
              const issueData = {
                id: issue.id,
                title: issue.title,
                createdAt: issue.createdAt,
                updatedAt: issue.updatedAt,
                projectId: issue.project.id,
                projectName: issue.project.name,
                priorityLabel: issue.priorityLabel || 'No priority',
                identifier: issue.identifier,
                assigneeName: issue.assignee
                  ? issue.assignee.name
                  : 'No assignee',
                state: issue.state ? issue.state.name : 'Triage',
                teamKey: issue.team.id,
                teamName: issue.team.name,
                dueDate: issue.dueDate || null,
              };

              // Update or create the issue
              await tx.issue.upsert({
                where: { id: issue.id },
                update: issueData,
                create: issueData,
              });

              // Process labels for this issue
              if (issue.labels && issue.labels.nodes.length > 0) {
                // First, delete any existing labels
                await tx.label.deleteMany({
                  where: { issueId: issue.id },
                });

                // Then add the current ones
                for (const label of issue.labels.nodes) {
                  await tx.label.create({
                    data: {
                      id: label.id,
                      name: label.name,
                      color: label.color,
                      parentId: label.parentId || null,
                      issueId: issue.id,
                    },
                  });
                }
              }
            } else {
              this.logger.warn(
                `Skipping issue ${issue.id}: Project ${issue.project.id} not found`,
              );
            }
          }
        }
      } catch (error) {
        this.logger.error(
          `Error synchronizing issues batch: ${error.message}`,
          error.stack,
        );
        throw error;
      }

      // Add a slight delay to avoid hitting rate limits
      if (hasNextPage) {
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }
  }

  /**
   * Clean up orphaned records after synchronization
   */
  private async cleanupOrphanedRecords(tx: any): Promise<void> {
    this.logger.log('Cleaning up orphaned records');

    // Get all Linear teams and projects
    const query = `
      query {
        teams { nodes { id } }
        projects { nodes { id } }
      }
    `;

    const data = await this.fetchFromLinear(query);

    const linearTeamIds = new Set(data.teams.nodes.map((t) => t.id));
    const linearProjectIds = new Set(data.projects.nodes.map((p) => p.id));

    // 1. Clean up orphaned projects (projects not in Linear)
    const orphanedProjects = await tx.project.findMany({
      where: {
        id: { notIn: Array.from(linearProjectIds) },
      },
      select: { id: true, name: true },
    });

    if (orphanedProjects.length > 0) {
      this.logger.warn(`Deleting ${orphanedProjects.length} orphaned projects`);
      for (const project of orphanedProjects) {
        await tx.project.delete({ where: { id: project.id } });
      }
    }

    // 2. Clean up orphaned teams (teams not in Linear)
    // Note: Be careful with teams as they might have manually created data
    const orphanedTeams = await tx.team.findMany({
      where: {
        id: { notIn: Array.from(linearTeamIds) },
      },
      include: {
        projects: { select: { id: true } },
        rates: { select: { id: true } },
      },
    });

    for (const team of orphanedTeams) {
      // Only delete teams that have no projects or rates
      if (team.projects.length === 0 && team.rates.length === 0) {
        this.logger.warn(`Deleting orphaned team: ${team.id}`);
        await tx.team.delete({ where: { id: team.id } });
      } else {
        this.logger.warn(
          `Team ${team.id} not found in Linear but has local data (${team.projects.length} projects, ${team.rates.length} rates). Keeping it.`,
        );
      }
    }

    // 3. Clean up orphaned rates (rates with invalid team references)
    const validTeamIds = new Set(
      (await tx.team.findMany({ select: { id: true } })).map((t) => t.id),
    );

    const orphanedRates = await tx.rate.findMany({
      where: {
        teamId: { notIn: Array.from(validTeamIds) },
      },
      select: { id: true, name: true, teamId: true },
    });

    if (orphanedRates.length > 0) {
      this.logger.warn(`Deleting ${orphanedRates.length} orphaned rates`);
      for (const rate of orphanedRates) {
        await tx.rate.delete({ where: { id: rate.id } });
      }
    }
  }
}

// ====== FILE: src\invoice\invoice.input.ts ======

import { Field, InputType, Int } from '@nestjs/graphql';

@InputType()
export class InvoiceQueryInput {
  @Field(() => Int, {
    nullable: false,
    description: 'Month of invoice',
  })
  month: number;

  @Field(() => Int, {
    nullable: false,
    description: 'Year of invoice',
  })
  year: number;

  @Field(() => String, {
    nullable: false,
    description: 'Team id for invoice',
  })
  teamId: string;
}

// ====== FILE: src\invoice\invoice.model.ts ======

import { ObjectType, Field, Float, Int } from '@nestjs/graphql';

@ObjectType()
export class Invoice {
  @Field(() => String)
  projectId: string;

  @Field(() => String)
  projectName: string;

  @Field(() => Float)
  totalHours: number;

  @Field(() => Float)
  totalCost: number;

  @Field(() => [RateDetail], { nullable: true })
  rates?: RateDetail[];
}

@ObjectType()
export class RateDetail {
  @Field(() => Int)
  rateId: number;

  @Field(() => String)
  rateName: string;

  @Field(() => Float)
  hours: number;

  @Field(() => Float)
  cost: number;

  @Field(() => Float)
  ratePerHour: number;
}

// ====== FILE: src\invoice\invoice.module.ts ======

import { Module } from '@nestjs/common';
import { InvoiceService } from './invoice.service';
import { InvoiceResolver } from './invoice.resolver';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  providers: [InvoiceService, InvoiceResolver],
  controllers: [],
})
export class InvoiceModule {}

// ====== FILE: src\invoice\invoice.resolver.ts ======

import { Args, Query, Resolver } from '@nestjs/graphql';
import { InvoiceService } from './invoice.service';
import { Invoice } from './invoice.model';

@Resolver(() => Invoice)
export class InvoiceResolver {
  constructor(private readonly invoiceService: InvoiceService) {}

  @Query(() => Invoice)
  async invoiceForProject(
    @Args('projectId') projectId: string,
    @Args('startDate') startDate: Date,
    @Args('endDate') endDate: Date,
  ): Promise<Invoice> {
    return this.invoiceService.generateInvoiceForProject(
      projectId,
      startDate,
      endDate,
    );
  }
}

// ====== FILE: src\invoice\invoice.service.ts ======

import { Injectable } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { Invoice, RateDetail } from './invoice.model';

@Injectable()
export class InvoiceService {
  constructor(private prisma: PrismaService) {}
  async generateInvoiceForProject(
    projectId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<Invoice> {
    const project = await this.prisma.project.findUnique({
      where: { id: projectId },
      include: {
        time: {
          where: {
            startTime: { gte: startDate },
            endTime: { lte: endDate },
          },
          include: {
            rate: true,
          },
        },
      },
    });

    if (!project) throw new Error('Project not found');

    let totalHours = 0;
    let totalCost = 0;
    const ratesMap: { [key: number]: RateDetail & { ratePerHour: number } } =
      {};

    project.time.forEach((entry) => {
      const hours = entry.totalElapsedTime / 3600000;
      totalHours += hours;
      totalCost += hours * entry.rate.rate;

      if (!ratesMap[entry.rateId]) {
        ratesMap[entry.rateId] = {
          rateId: entry.rateId,
          rateName: entry.rate.name,
          hours: 0,
          cost: 0,
          ratePerHour: entry.rate.rate,
        };
      }

      ratesMap[entry.rateId].hours += hours;
      ratesMap[entry.rateId].cost += hours * entry.rate.rate;
    });

    const rates = Object.values(ratesMap).map((rate) => ({
      ...rate,
      hours: Math.round(rate.hours * 100) / 100,
      cost: Math.round(rate.cost * 100) / 100,
    }));

    return {
      projectId: project.id,
      projectName: project.name,
      totalHours: Math.round(totalHours * 100) / 100,
      totalCost: Math.round(totalCost * 100) / 100,
      rates,
    };
  }
}

// ====== FILE: src\issue\issue.model.ts ======

import { Field, ObjectType } from '@nestjs/graphql';
import { Issue as IssueClient } from '@prisma/client';

@ObjectType()
export class Issue implements IssueClient {
  @Field(() => String)
  id: string;

  @Field(() => String)
  createdAt: string;

  @Field(() => String)
  updatedAt: string;

  @Field(() => String)
  title: string;

  @Field(() => String, { nullable: true })
  dueDate: string;

  @Field(() => String)
  projectId: string;

  @Field(() => String)
  priorityLabel: string;

  @Field(() => String)
  identifier: string;

  @Field(() => String)
  assigneeName: string;

  @Field(() => String)
  projectName: string;

  @Field(() => String)
  state: string;

  @Field(() => String)
  teamKey: string;

  @Field(() => String)
  teamName: string;

  @Field(() => [Label], { nullable: 'itemsAndList' })
  labels: Label[];
}

@ObjectType()
export class Label {
  @Field(() => String)
  id: string;

  @Field(() => String)
  color: string;

  @Field(() => String)
  name: string;

  @Field(() => String, { nullable: true })
  parentId: string;
}

// ====== FILE: src\issue\issue.module.ts ======

import { Module } from '@nestjs/common';
import { IssueService } from './issue.service';
import { IssueResolver } from './issue.resolver';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  providers: [IssueService, IssueResolver],
  exports: [IssueResolver],
})
export class IssueModule {}

// ====== FILE: src\issue\issue.resolver.ts ======

import { Query, Resolver } from '@nestjs/graphql';
import { IssueService } from './issue.service';
import { Issue } from './issue.model';

@Resolver(() => Issue)
export class IssueResolver {
  constructor(private issueService: IssueService) {}

  @Query(() => [Issue])
  async issues(): Promise<Issue[]> {
    const issues = await this.issueService.all();
    // Transform or assert the type as necessary
    return issues as Issue[];
  }
}

// ====== FILE: src\issue\issue.service.ts ======

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Issue } from '@prisma/client';
import { IssueWebhookData } from '../webhook/webhook.service';

@Injectable()
export class IssueService {
  constructor(private prisma: PrismaService) {}

  async all(): Promise<Issue[]> {
    return this.prisma.issue.findMany({
      include: {
        labels: true,
      },
    });
  }

  async create(data: IssueWebhookData): Promise<Issue> {
    // Make sure we have a valid projectId
    if (!data.projectId) {
      console.warn(`Cannot create issue ${data.id}: Missing projectId`);
      throw new Error('ProjectId is required to create an issue');
    }

    try {
      const createData: any = {
        id: data.id,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
        title: data.title,
        dueDate: data.dueDate,
        priorityLabel: data.priorityLabel || 'No Priority',
        identifier: data.identifier,
        assigneeName: data.assignee?.name || 'No Assignee',
        projectName: data.project?.name || 'Unknown Project',
        state: data.state?.name,
        teamName: data.team?.name,
        projectId: data.projectId,
      };

      // Only set teamKey if team exists and has an id
      if (data.team?.id) {
        createData.teamKey = data.team.id;
      }

      const createdIssue = await this.prisma.issue.create({
        data: createData,
      });

      return createdIssue;
    } catch (error) {
      console.error('Error creating issue:', error);
      throw error;
    }
  }

  async update(id: string, data: IssueWebhookData): Promise<Issue> {
    try {
      // First check if the issue exists
      const existingIssue = await this.prisma.issue.findUnique({
        where: { id },
        select: { id: true },
      });

      // Define update data with direct field assignments
      const updateData: any = {
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
        title: data.title,
        dueDate: data.dueDate,
        priorityLabel: data.priorityLabel || 'No Priority',
        identifier: data.identifier,
        assigneeName: data.assignee?.name || 'No Assignee',
        projectName: data.project?.name || 'Unknown Project',
        state: data.state?.name,
        teamName: data.team?.name,
      };

      // Only update projectId if it's provided
      if (data.projectId) {
        updateData.projectId = data.projectId;
      }

      // Handle team relationship directly with teamKey field
      if (data.team?.id) {
        updateData.teamKey = data.team.id;
      } else {
        updateData.teamKey = null; // Disconnect if no team
      }

      if (existingIssue) {
        // If issue exists, perform update
        const updatedIssue = await this.prisma.issue.update({
          where: { id },
          data: updateData,
        });

        console.log(`Updated issue ID: ${updatedIssue.id}`);
        return updatedIssue;
      } else {
        // If issue doesn't exist, create it
        return this.create(data);
      }
    } catch (error) {
      console.error(`Error updating issue ${id}:`, error);
      throw error;
    }
  }

  async createLabelForIssue(
    webhookLabel: IssueWebhookData['labels'][number],
    issueId: string,
  ): Promise<void> {
    await this.prisma.label.create({
      data: {
        id: webhookLabel.id,
        issueId,
        color: webhookLabel.color,
        name: webhookLabel.name,
        parentId: webhookLabel.parentId,
      },
    });
  }
  async updateLabelsForIssue(
    issueId: string,
    webhookLabels: IssueWebhookData['labels'],
  ): Promise<void> {
    await this.prisma.$transaction(async (prisma) => {
      // Get all labels connected to this issue
      const currentLabels = await prisma.label.findMany({
        where: { issueId },
      });

      // Process removed labels
      const currentLabelIds = currentLabels.map((label) => label.id);
      const removedLabelIds = currentLabelIds.filter(
        (id) => !webhookLabels.some((label) => label.id === id),
      );

      await this.prisma.label.deleteMany({
        where: {
          issueId,
          id: { in: removedLabelIds },
        },
      });

      // Process existing and new labels
      for (const webhookLabel of webhookLabels) {
        const existingLabel = currentLabels.find(
          (label) => label.id === webhookLabel.id,
        );

        if (existingLabel) {
          // Update existing label
          await this.prisma.label.update({
            where: { internalId: existingLabel.internalId },
            data: {
              color: webhookLabel.color,
              name: webhookLabel.name,
            },
          });
        } else {
          // Create new label
          await this.createLabelForIssue(webhookLabel, issueId);
        }
      }
    });
  }

  async remove(id: string): Promise<void> {
    await this.prisma.issue.delete({
      where: { id },
    });
  }

  // This method will check if an issue exists and create it if not
  async ensureIssueExists(
    issueId: string,
    data: IssueWebhookData,
  ): Promise<Issue> {
    let issue = await this.prisma.issue.findUnique({
      where: { id: issueId },
    });

    if (!issue) {
      // If the issue does not exist, create it using the existing 'create' method
      issue = await this.create(data);
    } else {
      await this.update(issueId, data);
    }

    return issue;
  }
}

// ====== FILE: src\issue-updates\issue-updates.gateway.ts ======

import {
  WebSocketGateway,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Logger } from '@nestjs/common';
import { Server, Socket } from 'socket.io';

@WebSocketGateway({ cors: { origin: '*' } })
export class IssueUpdatesGateway
  implements OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer() server: Server;
  private logger: Logger = new Logger('IssueUpdatesGateway');

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
  }

  broadcastIssueUpdate(issueUpdate: any) {
    this.server.emit('issueUpdate', issueUpdate);
    this.logger.debug(`Broadcasted issue update: ${issueUpdate.id}`);
  }
}

// ====== FILE: src\issue-updates\issue-updates.module.ts ======

import { Module } from '@nestjs/common';
import { IssueUpdatesGateway } from './issue-updates.gateway';

@Module({
  providers: [IssueUpdatesGateway],
  exports: [IssueUpdatesGateway],
})
export class IssueUpdatesModule {}

// ====== FILE: src\prisma\prisma.module.ts ======

import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}

// ====== FILE: src\prisma\prisma.service.ts ======

import {
  Injectable,
  OnModuleInit,
  OnModuleDestroy,
  Logger,
} from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  private readonly logger = new Logger(PrismaService.name);

  constructor() {
    super({
      log: ['query', 'info', 'warn', 'error'],
    });
  }

  async onModuleInit() {
    this.logger.log('Prisma Client initializing...');
    await this.$connect();
    this.logger.log('Prisma Client connected');
  }

  async onModuleDestroy() {
    this.logger.log('Prisma Client disconnecting...');
    await this.$disconnect();
    this.logger.log('Prisma Client disconnected');
  }
}

// ====== FILE: src\project\project.model.ts ======

import { Field, Int, ObjectType } from '@nestjs/graphql';
import { Project as ProjectClient } from '@prisma/client';

@ObjectType()
export class Project implements ProjectClient {
  @Field(() => String)
  id: string;

  @Field(() => Int)
  estimatedTime: number;

  @Field(() => String)
  name: string;

  @Field(() => String)
  teamId: string;
  // ---------------------------------
  @Field(() => String)
  createdAt: string;

  @Field(() => String)
  updatedAt: string;

  @Field(() => String)
  description: string;

  @Field(() => String)
  state: string;

  @Field(() => String)
  startDate: string;

  @Field(() => String)
  targetDate: string;

  // ---------------------------------
}

// ====== FILE: src\project\project.module.ts ======

import { Module } from '@nestjs/common';
import { ProjectService } from './project.service';
import { ProjectResolver } from './project.resolver';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  providers: [ProjectService, ProjectResolver],
  exports: [ProjectResolver],
})
export class ProjectModule {}

// ====== FILE: src\project\project.resolver.ts ======

import { Query, Resolver } from '@nestjs/graphql';
import { Project } from './project.model';
import { ProjectService } from './project.service';

@Resolver(() => Project)
export class ProjectResolver {
  constructor(private projectService: ProjectService) {}

  @Query(() => [Project])
  async projects(): Promise<Project[]> {
    return this.projectService.all();
  }
}

// ====== FILE: src\project\project.service.ts ======

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Project } from '@prisma/client';

@Injectable()
export class ProjectService {
  constructor(private prisma: PrismaService) {}

  async all(): Promise<Project[]> {
    return this.prisma.project.findMany();
  }

  async create(
    id: string,
    name: string,
    teamId: string,
    createdAt: string,
    updatedAt: string,
    description: string,
    state: string,
    startDate: string,
    targetDate: string,
  ): Promise<Project> {
    return this.prisma.project.create({
      data: {
        id,
        name,
        team: {
          connect: { id: teamId },
        },
        createdAt,
        updatedAt,
        description,
        state,
        startDate,
        targetDate,
      },
    });
  }

  async remove(id: string): Promise<Project | null> {
    try {
      return await this.prisma.project.delete({
        where: { id },
      });
    } catch (error) {
      console.error('Error in removing project:', error);
      // Handle or rethrow the error as appropriate
      return null;
    }
  }

  async update(
    id: string,
    name: string,
    teamId: string,
    createdAt: string,
    updatedAt: string,
    description: string,
    state: string,
    startDate: string,
    targetDate: string,
  ): Promise<Project> {
    return this.prisma.project.upsert({
      where: {
        id,
      },
      update: {
        name,
        teamId,
        updatedAt,
        description,
        state,
        startDate,
        targetDate,
      },
      create: {
        id,
        name,
        teamId,
        createdAt,
        updatedAt,
        description,
        state,
        startDate,
        targetDate,
      },
    });
  }
}

// ====== FILE: src\rate\rate.input.ts ======

import { Field, InputType, Int } from '@nestjs/graphql';

@InputType()
export class RateInputCreate {
  @Field(() => String, {
    nullable: false,
    description: 'Rate name',
  })
  name: string;

  @Field(() => Int, {
    nullable: false,
    description: 'Rate',
  })
  rate: number;

  @Field(() => String, {
    nullable: false,
    description: 'Rates team id',
  })
  teamId: string;
}

// ====== FILE: src\rate\rate.model.ts ======

import { Field, Int, ObjectType } from '@nestjs/graphql';
import { Rate as RateClient } from '@prisma/client';

@ObjectType()
export class Rate implements RateClient {
  @Field(() => Int)
  id: number;

  @Field(() => String)
  name: string;

  @Field(() => String)
  teamId: string;

  @Field(() => Int)
  rate: number;
}

// ====== FILE: src\rate\rate.module.ts ======

import { Module } from '@nestjs/common';
import { RateService } from './rate.service';
import { RateResolver } from './rate.resolver';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  providers: [RateService, RateResolver],
})
export class RateModule {}

// ====== FILE: src\rate\rate.resolver.ts ======

import { Args, Mutation, Query, Resolver, Int } from '@nestjs/graphql';
import { RateService } from './rate.service';
import { Rate } from './rate.model';
import { RateInputCreate } from './rate.input';

@Resolver()
export class RateResolver {
  constructor(private rateService: RateService) {}

  @Query(() => [Rate])
  async rates(@Args('teamId') teamId: string): Promise<Rate[]> {
    return this.rateService.all(teamId);
  }

  @Mutation(() => Rate)
  async createRate(
    @Args('rateInputCreate') rateInputCreate: RateInputCreate,
  ): Promise<Rate> {
    return this.rateService.create(
      rateInputCreate.name,
      rateInputCreate.rate,
      rateInputCreate.teamId,
    );
  }

  @Mutation(() => Rate)
  async deleteRate(
    @Args('rateId', { type: () => Int }) rateId: number,
  ): Promise<Rate> {
    console.log(`Attempting to delete rate with ID: ${rateId}`);
    return this.rateService.remove(rateId);
  }
}

// ====== FILE: src\rate\rate.service.ts ======

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Rate } from '@prisma/client';

@Injectable()
export class RateService {
  constructor(private prisma: PrismaService) {}

  all(teamId: string): Promise<Rate[]> {
    return this.prisma.rate.findMany({
      where: {
        teamId: teamId,
      },
    });
  }

  create(name: string, rate: number, teamId: string): Promise<Rate> {
    return this.prisma.rate.create({
      data: {
        name,
        rate,
        teamId,
      },
    });
  }

  async remove(id: number): Promise<Rate> {
    console.log('Removing rate with ID:', id);
    await this.prisma.time.updateMany({
      where: { rateId: id },
      data: { rateId: { set: null } }, // Or assign to a default rate ID
    });

    return this.prisma.rate
      .delete({
        where: {
          id,
        },
      })
      .catch((err) => {
        console.error('Error in removing rate:', err);
        throw err;
      });
  }
}

// ====== FILE: src\team\team.model.ts ======

import { Field, ObjectType } from '@nestjs/graphql';
import { Team as TeamClient } from '@prisma/client';
import { Project } from '../project/project.model';
import { Rate } from '../rate/rate.model';

@ObjectType()
export class Team implements TeamClient {
  @Field(() => String)
  id: string;

  @Field(() => String)
  name: string;

  @Field(() => [Project])
  projects: Project[];

  @Field(() => [Rate])
  rates: Rate[];
}

@ObjectType()
export class SimpleTeamDTO {
  @Field(() => String)
  id: string;

  @Field(() => String)
  name: string;
}

// ====== FILE: src\team\team.module.ts ======

import { Module } from '@nestjs/common';
import { TeamResolver } from './team.resolver';
import { TeamService } from './team.service';
import { ConfigModule } from '@nestjs/config';
import { HttpModule } from '@nestjs/axios';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [ConfigModule, HttpModule, PrismaModule],
  providers: [TeamResolver, TeamService],
  exports: [TeamService],
})
export class TeamModule {}

// ====== FILE: src\team\team.resolver.ts ======

import { Args, Mutation, Resolver, Query } from '@nestjs/graphql';
import { Team } from './team.model';
import { TeamService } from './team.service';
import { SimpleTeamDTO } from './team.model';

@Resolver(() => Team)
export class TeamResolver {
  constructor(private teamService: TeamService) {}

  @Mutation(() => Team)
  async createTeam(
    @Args('id') id: string,
    @Args('name') name: string,
  ): Promise<Team> {
    const team = await this.teamService.create(id, name);
    return {
      ...team,
      projects: [],
      rates: [],
    };
  }

  @Query(() => [SimpleTeamDTO])
  async getAllSimpleTeams(): Promise<SimpleTeamDTO[]> {
    return this.teamService.getAllSimpleTeams();
  }
}

// ====== FILE: src\team\team.service.ts ======

import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { Team } from '@prisma/client';
import { SimpleTeamDTO } from './team.model';

@Injectable()
export class TeamService {
  private readonly logger = new Logger(TeamService.name);

  constructor(private prisma: PrismaService) {}

  async create(id: string, name: string): Promise<Team> {
    this.logger.debug(`Creating team with id: ${id}, name: ${name}`);

    return this.prisma.$transaction(async (tx) => {
      return tx.team.create({
        data: {
          id,
          name,
          projects: { create: [] },
          rates: { create: [] },
        },
      });
    });
  }

  async getAllSimpleTeams(): Promise<SimpleTeamDTO[]> {
    this.logger.debug('Fetching all teams (simple format)');

    return this.prisma.$transaction(async (tx) => {
      return tx.team.findMany({
        select: {
          id: true,
          name: true,
        },
      });
    });
  }

  async getTeamById(id: string): Promise<Team | null> {
    this.logger.debug(`Fetching team with id: ${id}`);

    return this.prisma.$transaction(async (tx) => {
      return tx.team.findUnique({
        where: { id },
      });
    });
  }
}

// ====== FILE: src\time\time.input.ts ======

import { Field, InputType } from '@nestjs/graphql';

@InputType()
export class TimeInputCreate {
  @Field(() => Date, {
    nullable: false,
    description: 'Start time',
  })
  startTime: Date;

  @Field(() => Date, {
    nullable: true,
    description: 'End time',
  })
  endTime?: Date;

  @Field(() => String, {
    nullable: false,
    description: 'Project ID',
  })
  projectId: string;

  @Field(() => Number, {
    nullable: false,
    description: 'User ID',
  })
  userId: number;

  @Field(() => Number, {
    nullable: false,
    description: 'Rate ID',
  })
  rateId: number;

  @Field(() => Number, {
    nullable: false,
    description: 'Total Elapsed Time',
  })
  totalElapsedTime: number;
}

@InputType()
export class TimeInputUpdate {
  @Field(() => Number, {
    nullable: false,
    description: 'Time entry ID',
  })
  id: number;

  @Field(() => Date, {
    nullable: true,
    description: 'End time',
  })
  endTime?: Date;

  @Field(() => Number, {
    nullable: false,
    description: 'Total Elapsed Time',
  })
  totalElapsedTime: number;
}

// ====== FILE: src\time\time.model.ts ======

import { Field, ObjectType, Int } from '@nestjs/graphql';
import { Time as TimeClient } from '@prisma/client';

@ObjectType()
export class Time implements TimeClient {
  @Field(() => Int)
  id: number;

  @Field(() => Date)
  startTime: Date;

  @Field(() => Date, { nullable: true })
  endTime: Date | null;

  @Field(() => Int)
  userId: number;

  @Field(() => String)
  projectId: string;

  @Field(() => Int)
  rateId: number;

  @Field(() => Int, { nullable: true })
  totalElapsedTime: number | null;
}

// ====== FILE: src\time\time.module.ts ======

import { Module } from '@nestjs/common';
import { TimeService } from './time.service';
import { TimeResolver } from './time.resolver';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  providers: [TimeService, TimeResolver],
})
export class TimeModule {}

// ====== FILE: src\time\time.resolver.ts ======

import { Resolver, Query, Mutation, Args } from '@nestjs/graphql';
import { TimeService } from './time.service';
import { Time } from './time.model';
import { TimeInputCreate, TimeInputUpdate } from './time.input';

@Resolver(() => Time)
export class TimeResolver {
  constructor(private readonly timeService: TimeService) {}

  @Query(() => [Time])
  async times(@Args('projectId') projectId: string): Promise<Time[]> {
    return this.timeService.all(projectId);
  }

  @Mutation(() => Time)
  async createTime(
    @Args('timeInputCreate') timeInputCreate: TimeInputCreate,
  ): Promise<Time> {
    console.log(
      'Backend Resolver - Received Start Time:',
      timeInputCreate.startTime,
    );
    console.log(
      'Backend Resolver - Received End Time:',
      timeInputCreate.endTime,
    );
    const { startTime, projectId, userId, rateId, totalElapsedTime, endTime } =
      timeInputCreate;

    // Find an existing entry
    const existingEntry = await this.timeService.findExistingEntry(
      startTime,
      userId,
      projectId,
      rateId,
    );

    if (existingEntry) {
      return this.timeService.update(
        existingEntry.id,
        new Date(),
        totalElapsedTime,
      );
    } else {
      return this.timeService.create(
        startTime,
        projectId,
        userId,
        rateId,
        new Date(endTime),
        totalElapsedTime,
      );
    }
  }

  @Mutation(() => Time)
  async updateTime(
    @Args('timeInputUpdate') timeInputUpdate: TimeInputUpdate,
  ): Promise<Time> {
    const { id, endTime, totalElapsedTime } = timeInputUpdate;
    return this.timeService.update(id, endTime ?? new Date(), totalElapsedTime);
  }

  @Query(() => Number)
  async getTotalTimeSpent(
    @Args('userId') userId: number,
    @Args('projectId') projectId: string,
    @Args('startDate') startDate: string,
    @Args('endDate') endDate: string,
  ): Promise<number> {
    return this.timeService.getTotalTimeSpent(
      userId,
      projectId,
      new Date(startDate),
      new Date(endDate),
    );
  }

  @Query(() => Number)
  async getTotalTimeForUserProject(
    @Args('userId') userId: number,
    @Args('projectId') projectId: string,
  ): Promise<number> {
    return this.timeService.getTotalTimeForUserProject(userId, projectId);
  }

  @Mutation(() => Time)
  async deleteTime(@Args('id') id: number): Promise<Time> {
    return this.timeService.remove(id);
  }
}

// ====== FILE: src\time\time.service.ts ======

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Time } from '@prisma/client';

@Injectable()
export class TimeService {
  constructor(private prisma: PrismaService) {}

  all(projectId: string): Promise<Time[]> {
    return this.prisma.time.findMany({
      where: {
        projectId,
      },
    });
  }

  async isDuplicate(
    startTime: Date,
    userId: number,
    projectId: string,
    rateId: number,
  ): Promise<boolean> {
    const existingEntry = await this.prisma.time.findFirst({
      where: {
        startTime,
        userId,
        projectId,
        rateId,
      },
    });
    return !!existingEntry;
  }

  async findExistingEntry(
    startTime: Date,
    userId: number,
    projectId: string,
    rateId: number,
  ): Promise<Time | null> {
    return this.prisma.time.findFirst({
      where: {
        startTime,
        userId,
        projectId,
        rateId,
      },
    });
  }

  async create(
    startTime: Date,
    projectId: string,
    userId: number,
    rateId: number,
    endTime: Date,
    totalElapsedTime: number,
  ): Promise<Time> {
    console.log('Backend Service - Creating with Start Time:', startTime);
    console.log('Backend Service - Creating with End Time:', endTime);

    const duplicate = await this.isDuplicate(
      startTime,
      userId,
      projectId,
      rateId,
    );

    if (duplicate) {
      throw new Error('Duplicate time entry not allowed');
    }

    return this.prisma.time.create({
      data: {
        startTime,
        endTime, // endTime is now the actual time of submission
        projectId,
        userId,
        rateId,
        totalElapsedTime, // totalElapsedTime is the total active working time
      },
    });
  }

  update(
    id: number,
    endTime: Date,
    totalElapsedTime: number, // Directly use the provided totalElapsedTime
  ): Promise<Time> {
    return this.prisma.time.update({
      where: { id },
      data: {
        endTime, // Set the endTime to the time of submission
        totalElapsedTime, // Use the provided totalElapsedTime
      },
    });
  }

  remove(id: number): Promise<Time> {
    return this.prisma.time.delete({
      where: {
        id,
      },
    });
  }

  async getTotalTimeSpent(
    userId: number,
    projectId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<number> {
    console.log(
      `getTotalTimeSpent called with userId: ${userId}, projectId: ${projectId}, startDate: ${startDate.toISOString()}, endDate: ${endDate.toISOString()}`,
    );

    // Adjust startDate to the start of the day
    const adjustedStartDate = new Date(startDate);
    adjustedStartDate.setHours(0, 0, 0, 0);

    // Adjust endDate to include the entire day
    const adjustedEndDate = new Date(endDate);
    adjustedEndDate.setHours(23, 59, 59, 999);

    console.log('Executing database query to aggregate total time spent...');

    try {
      const aggregatedTime = await this.prisma.time.aggregate({
        where: {
          userId,
          projectId,
          AND: [
            {
              startTime: {
                gte: adjustedStartDate,
              },
            },
            {
              endTime: {
                lte: adjustedEndDate,
              },
            },
          ],
        },
        _sum: {
          totalElapsedTime: true,
        },
      });

      const totalTime = aggregatedTime._sum.totalElapsedTime || 0;
      console.log(`Total time spent for the given period: ${totalTime}`);
      return totalTime;
    } catch (error) {
      console.error('Error in getTotalTimeSpent:', error);
      throw error; // Re-throw the error after logging it
    }
  }

  async getTotalTimeForUserProject(
    userId: number,
    projectId: string,
  ): Promise<number> {
    const aggregatedTime = await this.prisma.time.aggregate({
      where: {
        userId,
        projectId,
      },
      _sum: {
        totalElapsedTime: true,
      },
    });

    return aggregatedTime._sum.totalElapsedTime || 0;
  }
}

// ====== FILE: src\user\user-role.enum.ts ======

import { registerEnumType } from '@nestjs/graphql';

export enum UserRole {
  ADMIN = 'ADMIN',
  ENABLER = 'ENABLER',
  COLLABORATOR = 'COLLABORATOR',
  PENDING = 'PENDING',
}

registerEnumType(UserRole, {
  name: 'UserRole',
});

// ====== FILE: src\user\user.input.ts ======

import { Field, InputType } from '@nestjs/graphql';
import { UserRole } from './user-role.enum';

@InputType()
export class UserInputCreate {
  @Field(() => String, {
    nullable: false,
    description: "User's email",
  })
  email: string;

  @Field(() => String, {
    nullable: false,
    description: "User's password",
  })
  password: string;

  @Field(() => UserRole, {
    nullable: true,
    description: "User's role",
  })
  role?: UserRole;
}

// ====== FILE: src\user\user.model.ts ======

import { Field, Int, ObjectType } from '@nestjs/graphql';
import { UserRole } from './user-role.enum';
import { Team } from '../team/team.model';

@ObjectType()
export class User {
  @Field(() => Int)
  id: number;

  @Field(() => String)
  email: string;

  @Field(() => UserRole)
  role: UserRole;

  @Field(() => [Team])
  teams?: Team[];
}

// ====== FILE: src\user\user.module.ts ======

import { Module, forwardRef } from '@nestjs/common';
import { UserService } from './user.service';
import { UserResolver } from './user.resolver';
import { AuthModule } from '../auth/auth.module';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [forwardRef(() => AuthModule), PrismaModule],
  providers: [UserResolver, UserService],
  exports: [UserResolver, UserService],
})
export class UserModule {}

// ====== FILE: src\user\user.resolver.ts ======

import { Args, Mutation, Query, Resolver, Int } from '@nestjs/graphql';
import { UseGuards } from '@nestjs/common';
import { User } from './user.model';
import { UserService } from './user.service';
import { Roles } from '../auth/roles.decorator';
import { AuthGuard } from '../auth/auth.guard';
import { UserRole } from './user-role.enum';

@Resolver(() => User)
export class UserResolver {
  constructor(private userService: UserService) {}

  @Query(() => [User])
  @Roles(UserRole.ADMIN, UserRole.ENABLER)
  @UseGuards(AuthGuard)
  async users(): Promise<User[]> {
    const users = await this.userService.all();
    console.log('Fetched users:', JSON.stringify(users, null, 2));
    return users.map((user) => ({
      ...user,
      role: UserRole[user.role as keyof typeof UserRole],
    }));
  }

  @Mutation(() => User)
  @Roles(UserRole.ADMIN)
  @UseGuards(AuthGuard)
  async updateUserRole(
    @Args('userId', { type: () => Int }) userId: number,
    @Args('newRole', { type: () => UserRole }) newRole: UserRole,
  ): Promise<User> {
    const updatedUser = await this.userService.updateUserRole(userId, newRole);
    console.log(
      'User after role update:',
      JSON.stringify(updatedUser, null, 2),
    );
    return {
      ...updatedUser,
      role: UserRole[updatedUser.role as keyof typeof UserRole],
    };
  }

  @Mutation(() => User)
  @Roles(UserRole.ADMIN)
  @UseGuards(AuthGuard)
  async addUserToTeam(
    @Args('userId', { type: () => Int }) userId: number,
    @Args('teamId') teamId: string,
  ): Promise<User> {
    const user = await this.userService.addUserToTeam(userId, teamId);
    console.log('User add:', JSON.stringify(user, null, 2));
    return {
      ...user,
      role: UserRole[user.role as keyof typeof UserRole],
    };
  }

  @Mutation(() => User)
  @Roles(UserRole.ADMIN)
  @UseGuards(AuthGuard)
  async removeUserFromTeam(
    @Args('userId', { type: () => Int }) userId: number,
    @Args('teamId') teamId: string,
  ): Promise<User> {
    try {
      const user = await this.userService.removeUserFromTeam(userId, teamId);
      console.log('User removed from team:', JSON.stringify(user, null, 2));
      return {
        ...user,
        role: UserRole[user.role as keyof typeof UserRole],
      };
    } catch (error) {
      console.error('Error occurred while removing user from team:', error);
      throw new Error('Error removing user from team');
    }
  }
}

// ====== FILE: src\user\user.service.ts ======

import { Injectable } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { User } from '@prisma/client';
import { UserRole } from '../user/user-role.enum';
import { User as QlUser } from '../user/user.model';

type TeamBasic = {
  id: string;
  name: string;
};

type UserTeam = {
  userId: number;
  teamId: string;
  user: {
    id: number;
    email: string;
    password?: string | null;
    role: UserRole;
  };
  team: TeamBasic;
};

@Injectable()
export class UserService {
  constructor(private prisma: PrismaService) {}
  async getUserTeams(): Promise<UserTeam[]> {
    const userTeams = await this.prisma.userTeam.findMany({
      include: {
        user: true,
        team: true,
      },
    });

    return userTeams.map((ut) => ({
      userId: ut.userId,
      teamId: ut.teamId,
      user: {
        id: ut.user.id,
        email: ut.user.email,
        role: UserRole[ut.user.role as keyof typeof UserRole],
        password: null,
      },
      team: {
        id: ut.team.id,
        name: ut.team.name,
        // other fields as needed
      },
    }));
  }

  async all(): Promise<QlUser[]> {
    const users = await this.prisma.user.findMany({
      select: {
        id: true,
        email: true,
        role: true,
        teams: {
          select: {
            team: {
              select: {
                id: true,
                name: true,
                projects: {
                  select: {
                    id: true,
                    estimatedTime: true,
                    name: true,
                    teamId: true,
                    createdAt: true,
                    updatedAt: true,
                    description: true,
                    state: true,
                    startDate: true,
                    targetDate: true,
                    // Add any other necessary fields here
                  },
                },
                rates: {
                  select: {
                    id: true,
                    name: true,
                    teamId: true,
                    rate: true,
                    // Add any other necessary fields here
                  },
                },
              },
            },
          },
        },
      },
    });

    return users.map((user) => ({
      id: user.id,
      email: user.email,
      role: UserRole[user.role as keyof typeof UserRole],
      teams: user.teams.map((ut) => ({
        id: ut.team.id,
        name: ut.team.name,
        projects: ut.team.projects, // Now fully populated
        rates: ut.team.rates, // Now fully populated
      })),
    }));
  }

  async findOne(email: string): Promise<User | undefined> {
    const user = await this.prisma.user.findFirst({
      where: {
        email,
      },
    });

    if (user) {
      return {
        ...user,
        role: UserRole[user.role as keyof typeof UserRole],
      };
    }

    return user;
  }

  async create(
    email: string,
    hashedPassword: string,
    role: UserRole,
  ): Promise<User> {
    return this.prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        role,
      },
    });
  }

  async count(): Promise<number> {
    return this.prisma.user.count();
  }

  async updateUserRole(userId: number, newRole: UserRole): Promise<User> {
    const updatedUser = await this.prisma.user.update({
      where: {
        id: userId,
      },
      data: {
        role: newRole,
      },
    });

    return {
      ...updatedUser,
      role: UserRole[updatedUser.role as keyof typeof UserRole],
    };
  }

  async addUserToTeam(userId: number, teamId: string): Promise<User> {
    // First, check if the user and team exist
    const userExists = await this.prisma.user.findUnique({
      where: { id: userId },
    });
    const teamExists = await this.prisma.team.findUnique({
      where: { id: teamId },
    });

    if (!userExists || !teamExists) {
      throw new Error('User or Team not found');
    }

    // Check if the relation already exists
    const existingRelation = await this.prisma.userTeam.findUnique({
      where: {
        userId_teamId: {
          userId,
          teamId,
        },
      },
    });

    // If the relation does not exist, create it
    if (!existingRelation) {
      await this.prisma.userTeam.create({
        data: {
          userId,
          teamId,
        },
      });
    }

    return this.getUserWithTeams(userId);
  }

  async removeUserFromTeam(userId: number, teamId: string): Promise<User> {
    console.log(`Attempting to remove team ${teamId} from user ${userId}`);

    // Log current state of the user and teams
    const userBeforeUpdate = await this.prisma.user.findUnique({
      where: { id: userId },
      include: { teams: true },
    });
    console.log('User before update:', userBeforeUpdate);

    try {
      const result = await this.prisma.userTeam.deleteMany({
        where: {
          userId: userId,
          teamId: teamId,
        },
      });

      if (result.count === 0) {
        console.warn(
          `No association found for user ${userId} with team ${teamId}. Nothing to delete.`,
        );
      } else {
        console.log(`Removed team ${teamId} from user ${userId}`);
      }
    } catch (error) {
      console.error(
        `Error while removing team ${teamId} from user ${userId}:`,
        error,
      );
    }

    // Fetch and log updated user info
    const updatedUser = await this.getUserWithTeams(userId);
    console.log('User after update:', updatedUser);

    return updatedUser;
  }

  private async getUserWithTeams(userId: number): Promise<User> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      include: {
        teams: {
          include: {
            team: {
              include: {
                projects: true,
                rates: true,
              },
            },
          },
        },
      },
    });

    if (!user) {
      throw new Error(`User with ID ${userId} not found`);
    }

    // Handling non-nullable fields
    user.teams = user.teams.map((ut) => ({
      ...ut,
      team: {
        ...ut.team,
        projects: ut.team.projects || [],
        rates: ut.team.rates || [],
      },
    }));

    return user;
  }
}

// ====== FILE: src\webhook\webhook.controller.ts ======

import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { WebhookService } from './webhook.service';
import { WebhookGuard } from './webhook.guard';
import { Public } from '../auth/auth.controller';

@Controller('webhook')
export class WebhookController {
  constructor(private webhookService: WebhookService) {}

  @Post()
  @Public()
  @UseGuards(WebhookGuard)
  async handle(@Body() body: any) {
    await this.webhookService.handle(body);
  }
}

// ====== FILE: src\webhook\webhook.guard.ts ======

import {
  Injectable,
  CanActivate,
  ExecutionContext,
  Logger,
  UnauthorizedException,
} from '@nestjs/common';
import * as crypto from 'crypto';

@Injectable()
export class WebhookGuard implements CanActivate {
  private readonly logger = new Logger(WebhookGuard.name);

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const linearSignature = request.headers['linear-signature'];
    const webhookSecret = process.env.WEBHOOK_SECRET || '';

    if (!linearSignature) {
      this.logger.warn('Missing Linear signature header');
      throw new UnauthorizedException('Missing Linear signature header');
    }

    this.logger.debug(`recevived Linear signature: ${linearSignature}`);
    this.logger.debug(
      `Webhook secret available: ${!!process.env.WEBHOOK_SECRET}`,
    );

    if (!webhookSecret) {
      this.logger.error('Webhook secret not configured');
      return false;
    }

    const payload = JSON.stringify(request.body);

    const signature = crypto
      .createHmac('sha256', process.env.WEBHOOK_SECRET || '')
      .update(payload)
      .digest('hex');

    this.logger.debug(`Calculated signature: ${signature}`);

    try {
      const isValid = signature === linearSignature;

      if (!isValid) {
        this.logger.warn('Signature mismatch - webhook validation failed');
        throw new UnauthorizedException('Invalid webhook signature');
      }

      return true;
    } catch (error) {
      this.logger.error('Error validating webhook signature', error);
      throw new UnauthorizedException('Error validating webhook signature');
    }
  }
}

// ====== FILE: src\webhook\webhook.issue.service.ts ======

import { Injectable, Logger } from '@nestjs/common';
import { IssueWebhookData, LinearWebhookBody } from './webhook.service';
import { IssueService } from '../issue/issue.service';
import { PrismaClient } from '@prisma/client';
import { IssueUpdatesGateway } from '../issue-updates/issue-updates.gateway';

const prisma = new PrismaClient();

@Injectable()
export class WebhookIssueService {
  private readonly logger = new Logger(WebhookIssueService.name);
  constructor(
    private issueService: IssueService,
    private readonly issueUpdatesGateway: IssueUpdatesGateway,
  ) {}

  async handleIssue(json: LinearWebhookBody) {
    if (json.type !== 'Issue') {
      console.error('Expected issue data, received:', json.type);
      return;
    }

    const issueData = json.data as IssueWebhookData;

    try {
      switch (json.action) {
        case 'create':
          console.log(`Processing issue create webhook for: ${issueData.id}`);

          const hasProjectForCreate = await this.ensureProjectId(issueData);
          if (!hasProjectForCreate) {
            console.warn(
              `Cannot create issue ${issueData.id}: No suitable project found`,
            );
            return;
          }

          const createdIssue = await this.createIssue(issueData);

          // Also update labels for newly created issue
          if (issueData.labels && issueData.labels.length > 0) {
            await this.issueService.updateLabelsForIssue(
              issueData.id,
              issueData.labels,
            );
          }

          this.issueUpdatesGateway.broadcastIssueUpdate(createdIssue);

          break;

        case 'update':
          console.log(`Processing issue update webhook for: ${issueData.id}`);

          // Check if the issue exists before trying to update
          const existingIssue = await prisma.issue.findUnique({
            where: { id: issueData.id },
            select: { id: true },
          });

          if (existingIssue) {
            // If issue exists, we can update it even without a projectId
            await this.updateExistingIssue(issueData);

            // Then update its labels if present
            if (issueData.labels) {
              await this.issueService.updateLabelsForIssue(
                issueData.id,
                issueData.labels,
              );
            }
          } else {
            // Issue doesn't exist, need projectId for creation
            const hasProjectForUpdate = await this.ensureProjectId(issueData);
            if (!hasProjectForUpdate) {
              console.warn(
                `Cannot create non-existent issue ${issueData.id} via update: Missing projectId and no suitable default found`,
              );
              return; // Skip further processing
            }

            await this.createIssue(issueData);

            if (issueData.labels && issueData.labels.length > 0) {
              await this.issueService.updateLabelsForIssue(
                issueData.id,
                issueData.labels,
              );
            }
          }

          const updatedIssue = await this.updateExistingIssue(issueData);
          this.issueUpdatesGateway.broadcastIssueUpdate(updatedIssue);
          break;

        case 'remove':
          console.log(`Processing issue remove webhook for: ${issueData.id}`);
          await this.issueService.remove(issueData.id);

          this.issueUpdatesGateway.broadcastIssueUpdate({
            id: issueData.id,
            action: 'remove',
          }); // Broadcast remove event, send minimal info
          await this.issueService.remove(issueData.id);
          break;

        default:
          console.log('Unhandled webhook action:', json.action);
      }
    } catch (error) {
      if (error.message.includes('Missing projectId')) {
        console.warn(
          `Could not process issue ${issueData.id}: Missing projectId. This might be a standalone issue not connected to any project.`,
        );
      } else {
        console.error(
          `Error processing webhook for issue ${issueData.id}:`,
          error.message,
        );
      }
    }
  }

  private async ensureProjectId(data: IssueWebhookData): Promise<boolean> {
    // Try to get projectId from project.id if projectId is missing
    if (!data.projectId && data.project?.id) {
      data.projectId = data.project.id;
      return true;
    }

    // If still no projectId, try to find a default project
    if (!data.projectId) {
      try {
        // First attempt: Try to find a project associated with the team if available
        if (data.team?.id) {
          const teamProject = await prisma.project.findFirst({
            where: { teamId: data.team.id },
            select: { id: true, name: true },
            orderBy: { createdAt: 'desc' },
          });

          if (teamProject) {
            console.log(
              `Using team's project: ${teamProject.name} (${teamProject.id}) for issue ${data.id}`,
            );
            data.projectId = teamProject.id;
            data.projectName = teamProject.name;
            return true;
          }
        }

        // Second attempt: Try to find any available project
        const anyProject = await prisma.project.findFirst({
          select: { id: true, name: true },
          orderBy: { createdAt: 'desc' },
        });

        if (anyProject) {
          console.log(
            `Using default project: ${anyProject.name} (${anyProject.id}) for issue ${data.id}`,
          );
          data.projectId = anyProject.id;
          data.projectName = anyProject.name;
          return true;
        }

        const unassignedProject = await this.createOrGetUnassignedProject();
        if (unassignedProject) {
          console.log(`Using "Unassigned" project for issue ${data.id}`);
          data.projectId = unassignedProject.id;
          data.projectName = unassignedProject.name;
          return true;
        }

        // If we reach here, we couldn't find or create a suitable project
        console.warn(`Could not find any project for issue ${data.id}`);
        return false;
      } catch (error) {
        console.error(`Error finding default project: ${error.message}`);
        return false;
      }
    }

    return true;
  }

  // Helper method to create or get an "Unassigned" project
  private async createOrGetUnassignedProject() {
    const UNASSIGNED_PROJECT_ID = 'unassigned-project-id'; // Use a fixed ID

    try {
      // Try to find existing unassigned project
      const existingProject = await prisma.project.findUnique({
        where: { id: UNASSIGNED_PROJECT_ID },
      });

      if (existingProject) {
        return existingProject;
      }

      // Create unassigned project if it doesn't exist
      // First need to make sure there's at least one team
      const team = await prisma.team.findFirst();
      if (!team) {
        console.error('Cannot create unassigned project: No teams exist');
        return null;
      }

      // Create the project
      return await prisma.project.create({
        data: {
          id: UNASSIGNED_PROJECT_ID,
          name: 'Unassigned',
          teamId: team.id,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          state: 'Unassigned',
          description: 'Automatically created for issues without projects',
        },
      });
    } catch (error) {
      console.error(`Error creating unassigned project: ${error.message}`);
      return null;
    }
  }

  private async createIssue(data: IssueWebhookData) {
    try {
      // Ensure we have a projectId
      if (!this.ensureProjectId(data)) {
        throw new Error(
          `Issue ${data.id} has no projectId and no default project is available`,
        );
      }

      return await this.issueService.create(data);
    } catch (error) {
      console.error(`Failed to create issue ${data.id}:`, error.message);
      throw error;
    }
  }

  private async updateExistingIssue(data: IssueWebhookData) {
    try {
      const updateData: any = {
        updatedAt: data.updatedAt,
        title: data.title,
        dueDate: data.dueDate,
        priorityLabel: data.priorityLabel || 'No Priority',
        identifier: data.identifier,
        assigneeName: data.assignee?.name || 'No Assignee',
        state: data.state?.name,
        teamName: data.team?.name,
      };

      // Only include projectName and projectId if they exist
      if (data.project?.name) {
        updateData.projectName = data.project.name;
      }

      if (data.projectId) {
        updateData.projectId = data.projectId;
      }

      // Handle team relationship
      if (data.team?.id) {
        updateData.teamKey = data.team.id;
      }

      // Update the issue directly using prisma to avoid the create fallback
      await prisma.issue.update({
        where: { id: data.id },
        data: updateData,
      });

      return { id: data.id };
    } catch (error) {
      console.error(
        `Failed to update existing issue ${data.id}:`,
        error.message,
      );
      throw error;
    }
  }

  private async updateIssue(data: IssueWebhookData) {
    try {
      // Try to get projectId from project.id if projectId is missing
      this.ensureProjectId(data);

      return await this.issueService.update(data.id, data);
    } catch (error) {
      console.error(`Failed to update issue ${data.id}:`, error.message);
      throw error;
    }
  }
}

// ====== FILE: src\webhook\webhook.module.ts ======

import { Module } from '@nestjs/common';
import { WebhookService } from './webhook.service';
import { WebhookController } from './webhook.controller';
import { WebhookProjectService } from './webhook.project.service';
import { ProjectService } from '../project/project.service';
import { WebhookIssueService } from './webhook.issue.service';
import { IssueService } from '../issue/issue.service';
import { TeamModule } from '../team/team.module';
import { IssueUpdatesModule } from '../issue-updates/issue-updates.module';
import { PrismaModule } from '../prisma/prisma.module';
import { DatabaseSyncModule } from '../dbSynch/dbSynch.module';
@Module({
  imports: [TeamModule, IssueUpdatesModule, PrismaModule, DatabaseSyncModule],
  providers: [
    ProjectService,
    WebhookService,
    WebhookProjectService,
    IssueService,
    WebhookIssueService,
  ],
  controllers: [WebhookController],
})
export class WebhookModule {}

// ====== FILE: src\webhook\webhook.project.service.ts ======

import { Injectable } from '@nestjs/common';
import { ProjectWebhookData, LinearWebhookBody } from './webhook.service';
import { ProjectService } from '../project/project.service';

@Injectable()
export class WebhookProjectService {
  constructor(private projectService: ProjectService) {}

  async handleProject(json: LinearWebhookBody) {
    if (json.type !== 'Project') {
      console.error('Expected project data, received:', json.type);
      return;
    }
    switch (json.action) {
      case 'create':
        await this.create(json.data);
        break;
      case 'remove':
        await this.remove(json.data);
        break;
      case 'update':
        await this.update(json.data);
        break;
      default:
        console.log('UNMATCHED WEBHOOK FROM LINEAR');
        break;
    }
  }

  async create(json: LinearWebhookBody['data']) {
    const projectData = json as ProjectWebhookData;
    await this.projectService.create(
      projectData.id,
      projectData.name,
      projectData.teamIds[0],
      projectData.createdAt,
      projectData.updatedAt,
      projectData.description,
      projectData.state || 'Active',
      projectData.startDate,
      projectData.targetDate,
    );
  }

  async remove(json: LinearWebhookBody['data']) {
    await this.projectService.remove(json.id);
  }

  async update(json: LinearWebhookBody['data']) {
    const projectData = json as ProjectWebhookData;
    await this.projectService.update(
      projectData.id,
      projectData.name,
      projectData.teamIds[0],
      projectData.createdAt,
      projectData.updatedAt,
      projectData.description,
      projectData.state || 'Active',
      projectData.startDate,
      projectData.targetDate,
    );
  }
}

// ====== FILE: src\webhook\webhook.service.ts ======

import { Injectable, Logger } from '@nestjs/common';
import { WebhookProjectService } from './webhook.project.service';
import { WebhookIssueService } from './webhook.issue.service';
import { TeamService } from '../team/team.service';
import { DatabaseSyncService } from '../dbSynch/dbSynch.service';

export type ProjectWebhookData = {
  id: string;
  name: string;
  teamIds: string[];
  createdAt: string;
  updatedAt: string;
  description: string;
  state: string;
  startDate: string;
  targetDate: string;
};

export type IssueWebhookData = {
  id: string;
  createdAt: string;
  updatedAt: string;
  title: string;
  dueDate: string;
  projectId: string;
  priorityLabel: string;
  identifier: string;
  assignee?: {
    id: string;
    name: string;
  };
  project?: {
    id: string;
    name: string;
  };
  state?: {
    id: string;
    color: string;
    name: string;
    type: string;
  };
  team?: {
    id: string;
    key: string;
    name: string;
  };
  labels?: Array<{ id: string; name: string; color: string; parentId: string }>;
  projectName?: string;
};

export type LinearWebhookBody = {
  action: 'create' | 'remove' | 'update';
  data: ProjectWebhookData | IssueWebhookData;
  type: 'Project' | 'Issue';
};

@Injectable()
export class WebhookService {
  private readonly logger = new Logger(WebhookService.name);

  constructor(
    private webhookProjectService: WebhookProjectService,
    private webhookIssueService: WebhookIssueService,
    private teamService: TeamService,
    private databaseSyncService: DatabaseSyncService,
  ) {}

  async handle(json: LinearWebhookBody) {
    if (json.type == 'Project') {
      const projectData = json.data as ProjectWebhookData;
      const teamId = projectData.teamIds[0];
      // Check if the team associated with the project exists
      const team = await this.teamService.getTeamById(teamId);
      if (!team) {
        // Synchronize teams using the LinearService
        this.logger.log('Team not found. Synchronizing from Linear.');

        await this.databaseSyncService.synchronizeTeamsOnly();

        // Re-check if the team is now present after synchronization
        const synchronizedTeam = await this.teamService.getTeamById(teamId);
        if (!synchronizedTeam) {
          this.logger.error(
            'Team still not found after synchronization. Cannot process project.',
          );
          return;
        }
      }
      await this.webhookProjectService.handleProject(json);
    } else if (json.type === 'Issue') {
      await this.webhookIssueService.handleIssue(json);
    }
  }
}
